---
title: "[面试]-校招操作系统知识"
date: 2020-12-16 11:20:54
description: "Operation systeam"
tags:
-
series:
- Interview
categories:
- Code

image: images/feature1/flowchart.png
---





## Linux

![image-20200902214702059](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200902214702059.png)

#### 用户态, 内核态

> https://zhuanlan.zhihu.com/p/69554144

* 内核，它是一种**特殊的软件程序**,**控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行**。

  用户态就是提供应用程序运行的空间，为了使应用程序访问到内核管理的资源例如CPU，内存，I/O。内核必须提供一组通用的访问接口，这些接口就叫**系统调用。**

  

> **给不同的操作给与不同的“权限”**。Linux操作系统就将权限等级分为了2个等级，分别就是内核态和用户态。

![image-20200812211412621](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200812211412621.png)

![image-20200815224732295](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200815224732295.png)



#### Fork

> * 一个现有进程可以调用fork函数创建一个新进程。由fork创建的新进程被称为子进程（child process）。fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值而[父进程](https://baike.baidu.com/item/父进程)中返回子进程ID。
>
> * 子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。
> * 调用fork之后，数据、堆、栈有两份，代码仍然为一份但是这个[代码段](https://baike.baidu.com/item/代码段)成为两个进程的共享代码段都从fork函数中返回，箭头表示各自的执行处。当父子进程有一个想要修改数据或者堆栈时，两个进程真正分裂

*vFork*()

- 1.fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段
- 2.fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。
- 3.vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。
- 4.当需要改变共享数据段中变量的值，则拷贝父进程。

#### Chmod权限



> * chmod 741     r读 w写 x执行   r=4, w=2, x=1
>
> 第一个数字表示文件所有者的权限 
> 第二个数字表示与文件所有者同属一个用户组的其他用户的权限
> 第三个数字表示其它用户组的权限。
>
> * chmod 4755与chmod 755 的区别在于开头多了一位，这个4表示其他用户执行文件时，具有与所有者相当的权限



#### 缓冲 与 缓存



* 缓冲区

缓冲区(buffer)，它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区，显然缓冲区是具有一定大小的。

缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。

![image-20200831104401236](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200831104401236.png)



下列情况会引发缓冲区的刷新:

- 缓冲区满时；
- 关闭文件。





#### IO多路复用



单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力。



* 阻塞式I/O

![image-20200824095743639](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824095743639.png)



* 非阻塞式 (轮询)

* I/O多路复用

![image-20200824095855942](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824095855942.png)



* IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程





![image-20200824171018312](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824171018312.png)



![image-20200824100231640](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824100231640.png)



select 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。



![image-20200824223427021](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824223427021.png)



* epoll的工作模式



*工作模式*



1. LT 模式

当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。

2. ET 模式

和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。

很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。





## 操作系统



### 内存管理

块与页的关系：操作系统经常与内存和硬盘这两种存储设备进行通信，类似于“块”的概念，都需要一种虚拟的基本单位。所以，*与内存操作，是虚拟一个页的概念来作为最小单位*。与硬盘打交道，就是以块为最小单位



#### 虚拟内存

* 一个进程不用全部进入内存, 与磁盘进行映射.建立虚拟内存.
* 为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令
* 虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。

![image-20200815233314455](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200815233314455.png)



##### 虚拟地址转换成物理地址

操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表。页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址

![image-20200819105752023](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200819105752023.png)





> 两级页表:
>
> * 两级分页机制将32位的虚拟空间分成三段，低十二位表示页内偏移，高20分成两段分别表示两级页表的偏移。
>
> ![image-20200815234805503](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200815234805503.png)



* 虚拟地址->物理地址:

  ![image-20200815222302207](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200815222302207.png)

---

![image-20200815233433512](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200815233433512.png)



![image-20200819105652934](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200819105652934.png)



##### 页面调度算法

LRU: 

时间片: 环形链表,依次出

FIFO

第二次机会(FIFO改进)

![image-20200815223155203](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200815223155203.png)



#### 段 页式存储

程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。

![image-20200815223429817](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200815223429817.png)



#### 缺页中断

- malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。
- 缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。
- 缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：
  - 1.保护CPU现场
  - 2.分析中断原因
  - 3.转入缺页中断处理程序进行处理
  - 4.恢复CPU现场，继续执行
- 但是，如果缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断时。因此，与一般的中断存在区别：
  - 1.在指令执行期间产生和处理缺页中断信号
  - 2.一条指令在执行期间，可能产生多次缺页中断
  - 3.缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。

### 磁盘

> 磁盘块：逻辑层面： **磁盘块（虚拟出来的）。 块是操作系统中最小的逻辑存储单位。操作系统与磁盘打交道的最小单位是磁盘块。**  操作系统是通过块簇来做为单位读取等操作数据的**。文件系统就是操作系统的一部分，所以文件系统操作文件的最小单位是块。
>
> 目的：1.读取方便：由于扇区的数量比较小，数目众多在寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。2.分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为块是最小的单位

#### 磁盘结构

> - 盘面（Platter）：一个磁盘有多个盘面；
> - 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；
> - 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；
> - 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；
> - 制动手臂（Actuator arm）：用于在磁道之间移动磁头；
> - 主轴（Spindle）：使整个盘面转动。

![image-20200815223555242](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200815223555242.png)

#### 磁盘调度

* 最短寻道
* 电梯算法
* 先来先服务



### *进程和线程*

> 线程是独立调度的基本单位。
>
> 一个进程中可以有多个线程，它们共享进程资源。

##### 并发 并行

> * 并发: 宏观上一段时间内能同时运行多个程序
> * 并行: 同一时刻能运行多个指令

##### *区别*

> * 拥有资源
>
> 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。
>
> * 调度
>
> 线程是独立调度的基本单位，在同一进程中，*线程的切换不会引起进程切换*，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。
>
> * 系统开销
>
> 由于创建或撤销*进程*时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销*线程*时的开销。
>
> 类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
>
> * 通信方面
>
> 线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。
>
> ![image-20200814205933707](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200814205933707.png)
>

##### Linux的进程线程无区别

* 计算机结构:

![image-20200817111350658](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817111350658.png)

* 内核角度看没有区别

系统调用 fork() 可以新建一个子进程，函数 pthread() 可以新建 一个线程。**但无论线程还是进程，都是用** **task_struct** **结构表示的，唯一的 区别就是共享的数据区域不同**。

换句话说，线程看起来跟进程没有区别，只是线程的某些数据区域和其父进 程是共享的，而子进程是拷⻉副本，而不是共享。就比如说， mm 结构
 和 files 结构在线程中都是共享的

![image-20200817110159449](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817110159449.png)



![image-20200817110311791](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817110311791.png)



##### 进程/线程通信

进程通信方法:

* pipe()管道: 

> 管道的通信介质是文件，这种文件通常称为管道文件，两个进程利用管道文件进行通信时，一个进程为写进程，另一个进程为读进程。写进程通过写端（发送端）往管道文件中写入信息；读进程通过读端（接收端）从管道文件中读取信息
>
> 
>
> 通过fork()进行, 在内存缓冲区.
>
> * 只支持单向交替传输
> * 只能在父子或兄弟进程使用



* 消息队列

> ![image-20200814210447128](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200814210447128.png)
>
> - 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
> - 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
> - 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

* 信号:

> 信号是一种比较复杂的通信方式，信号产生的条件：按键、硬件异常、进程调用kill函数将信号发送给另一个进程、用户调用kill命令将信号发送给其他进程，信号传递的消息比较少，主要用于通知接收进程某个时间已经发生。

* 共享内存

![image-20200814210701617](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200814210701617.png)

![image-20200815212714552](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200815212714552.png)

* 本地套接字

进程间通信的一种方式是使用UNIX套接字sockaddr_un，人们在使用这种方式时往往用的不是网络套接字，而是一种称为本地套接字的方式。本地套接字用于本地进程间的通讯更安全和稳定。

使用套接字函数socket创建，不过传递的参数与网络套接字不同。域参数应该是PF_LOCAL或者PF_UNIX，而不能用PF_INET之类。本地套接字的通讯类型应该是SOCK_STREAM或SOCK_DGRAM，协议为默认协议。



*线程通信*

> - 临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问；
> - 互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
> - 信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。
> - 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。





##### 进程同步

* 同步与互斥

> 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
>
> 互斥：多个进程在同一时刻只有一个进程能进入临界区。



* 临界区: 对临界资源进行访问的代码



* 信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。
  - **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
  - **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。
  - 如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。

* 管程: 

> 使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。
>
> 管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。
>
> 管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

* 生产者消费者

![image-20200814215805809](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200814215805809.png)



读者写者

![image-20200814220744221](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200814220744221.png)



##### 死锁



* 必要条件

> 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
>
> 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
>
> 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
>
> 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

* 解决方法

> `鸵鸟`
>
> `修复`: 回滚,抢占, 杀死进程....	
>
> `预防`:破坏四个条件
>
> `避免`: 银行家算法

* 银行家算法:

为了实现银行家算法，必须设置以下四个数据结构:
（1）可利用资源向量Available:其初始值是系统中所配置的该类全部可用资源的数目。
（2）最大需求矩阵Max:它定义了系统中n个进程中的每一个进程对m类资源的最大需求。
（3）分配矩阵Allocation:它定义了系统中每一类资源当前已分配给每一个进程的资源数。
（4）需求矩阵Need：用一表示每一个进程尚需的各类资源数

> （1）如果Request(i)[j] <= Need[i,j],便转向步骤2,否则出错；
> （2）如果Request(i)[j] <= Available[j],便转向步骤3，否则出错；
> （3）系统试探着把资源分配给进程P,并修改下面数据结构中的数值:
> (**非常重要**)
> Available[j] = Avaliable[j] - Request(i)[j];
> Allocation[i,j] = Allocation[i,j] + Request(i)[j];
> Need[i,j] = Need[i,j] - Request(i)[j];
> （4）执行*安全性算法*,检查此次资源分配后系统是否处于*安全状态*。安全则分配，否则分配作废。

*安全性算法*: 剩下的资源能否满足任一进程的所有要求.





#### 有了进程，为什么还要有线程？

- **线程产生的原因**：进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：进程在同一时间只能干一件事、进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。

- 因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。

  和进程相比，线程的优势如下

  - 从资源上来讲，线程是一种非常"节俭"的多任务操作方式。在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种"昂贵"的多任务工作方式。
  - 从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。
  
  ![image-20200818094442079](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818094442079.png)
  
  - 从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。
  - 使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。
  - 改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。

#### 多线程和多进程的不同?

- **进程是资源分配的最小单位，而线程时CPU调度的最小单位。多线程之间共享同一个进程的地址空间，线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存少，适用于多核分布式系统，但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程也终止，程序可靠性弱**。而多进程间拥有各自独立的运行地址空间，**进程间不会相互影响，程序可靠性强，但是进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单，适用于多核、多机分布**。



* 线程共享的资源

![image-20200831165158571](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200831165158571.png)



#### 正常进程、孤儿进程、僵尸进程



*wait()*

```
pid_t wait(int *status)
```

父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。

如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。

参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。



*waitpid()*

```
pid_t waitpid(pid_t pid, int *status, int options)
```

作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。

pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。

options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。



>1.正常进程：**正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态**。unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息，直到父进程通过wait / waitpid来取时才释放。保存信息包括：
>
>- 进程号the process ID
>- 退出状态the termination status of the process
>- 运行时间the amount of CPU time taken by the process等
>
>2.孤儿进程：
>
>一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。
>
>孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。
>
>由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。
>
>
>
>3.僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。**僵尸进程是一个进程必然会经过的过程：这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态**。如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。

危害： 如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程



**解决方法：**

- 外部消灭：通过kill发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源。
- 内部解决：**子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程；fork两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程**。









### 缓存结构



#### CPU 三级缓存



![image-20200922100631600](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200922100631600.png)



CPU试图通过某一存储单元地址访问数据时，它会自上而下依次从L1、L2、L3、主存中查找，若找到则直接返回对应Cache中的数据而不再向下查找，如果L1、L2、L3都cache miss了，那么CPU将不得不通过总线访问主存或者硬盘上的数据。





#### 缓存Cache结构



整个Cache被分为S个组，每个组又有E行个最小的存储单元——Cache Line所组成，而一个Cache Line中有B（B=64）个字节用来存储数据，即每个Cache Line能存储64个字节的数据，每个Cache Line又额外包含1个有效位（`valid bit`）、**t**个标记位（`tag bit`），其中`valid bit`用来表示该*缓存行是否有效*；`tag bit`用来*协助寻址*，*唯一标识存储在Cache Line中的块*；而**Cache Line里的64个字节其实是对应内存地址中的数据拷贝**。根据Cache的结构，我们可以推算出每一级Cache的大小为B×E×S。



<img src="/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200922101038590.png" alt="image-20200922101038590" style="zoom:50%;" />









