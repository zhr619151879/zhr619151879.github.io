[{"content":"sadfsdf\n","description":"山无陵","id":0,"section":"showcase","tags":null,"title":"My Open Source here","uri":"https://zhr619151879.github.io/showcase/hugo/hugo-theme-zzo/"},{"content":"Dockerfile   Dockerfie 官方文档：https://docs.docker.com/engine/reference/builder/\n  Dockerfile 最佳实践文档：https://docs.docker.com/develop/develop-images/dockerfile_best-practices/\n  Docker 官方镜像 Dockerfile：https://github.com/docker-library/docs\n  Dockerfile 指令详解 COPY 复制文件 ADD 更高级的复制文件 CMD 容器启动命令 ENTRYPOINT 入口点 ENV 设置环境变量 VOLUME 定义匿名卷 WORKDIR 指定工作目录 EXPOSE 声明端口 ARG 构建参数 ","description":"详解Dockerfile","id":1,"section":"posts","tags":[""],"title":"[Docker详解]-3:揭秘Dockerfile","uri":"https://zhr619151879.github.io/posts/series/docker/%E6%8F%AD%E7%A7%98docker-3/"},{"content":"使用镜像 获取镜像  从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：  docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n具体的选项可以通过 docker pull \u0026ndash;help 命令看\n 镜像名称格式:    Docker 镜像仓库地址：地址的格式一般是 \u0026lt;域名/IP\u0026gt;[:端口号]。默认地址是 Docker Hub(docker.io)。 仓库名：如之前所说，这里的仓库名是两段式名称，即 \u0026lt;用户名\u0026gt;/\u0026lt;软件名\u0026gt;。对于 Docker Hub，如果不给出用户名，则默认为 library，也就是官方镜像。   如:\n1  docker pull ubuntu:18.04   上面的命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub 获取镜像。而镜像名称是 ubuntu:18.04，因此将会获取官方镜像 library/ubuntu 仓库中标签为 18.04 的镜像。\n运行镜像 有了镜像后，我们就能够以这个镜像为基础启动并运行一个容器。以上面的 ubuntu:18.04 为例\n1  docker run -it --rm ubuntu:18.04 bash    docker run 就是运行容器的命令，具体格式我们会在 容器 一节进行详细讲解，我们这里简要的说明一下上面用到的参数。\n -it：这是两个参数，一个是 -i：交互式操作，一个是 -t 终端。我们这里打算进入 bash 执行一些命令并查看返回结果，因此我们需要交互式终端。 \u0026ndash;rm：这个参数是说容器退出后随之将其删除。默认情况下，为了排障需求，退出的容器并不会立即删除，除非手动 docker rm。我们这里只是随便执行个命令，看看结果，不需要排障和保留结果，因此使用 \u0026ndash;rm 可以避免浪费空间。\nubuntu:18.04：这是指用 ubuntu:18.04 镜像为基础来启动容器。 bash：放在镜像名后的是 命令，这里我们希望有个交互式 Shell，因此用的是 bash。 进入容器后，我们可以在 Shell 下操作，执行任何所需的命令。这里，我们执行了 cat /etc/os-release，这是 Linux 常用的查看当前系统版本的命令，从返回的结果可以看到容器内是 Ubuntu 18.04.1 LTS 系统。 最后我们通过 exit 退出了这个容器。   列出镜像 要想列出已经下载下来的镜像，可以使用 docker image ls 命令。\n1 2 3 4 5 6 7 8  $ docker image ls REPOSITORY TAG IMAGE ID CREATED SIZE redis latest 5f515359c7f8 5 days ago 183 MB nginx latest 05a60462f8ba 5 days ago 181 MB mongo 3.2 fe9198c04d62 5 days ago 342 MB \u0026lt;none\u0026gt; \u0026lt;none\u0026gt; 00285df0df87 5 days ago 342 MB ubuntu 18.04 f753707788c5 4 weeks ago 127 MB ubuntu latest f753707788c5 4 weeks ago 127 MB   其中仓库名、标签在之前的基础概念章节已经介绍过了。镜像 ID 则是镜像的唯一标识，一个镜像可以对应多个 标签。因此，在上面的例子中，我们可以看到 ubuntu:18.04 和 ubuntu:latest 拥有相同的 ID，因为它们对应的是同一个镜像。\n列出部分镜像  根据仓库名列出镜像  1  $ docker image ls ubuntu    列出特定的某个镜像  1  $ docker image ls ubuntu:18.04    除此以外，docker image ls 还支持强大的过滤器参数 \u0026ndash;filter，或者简写 -f。之前我们已经看到了使用过滤器来列出虚悬镜像的用法，它还有更多的用法。比如，我们希望看到在 mongo:3.2 之后建立的镜像，可以用下面的命令：  1  $ docker image ls -f since=mongo:3.2   想查看某个位置之前的镜像也可以，只需要把 since 换成 before 即可。\n 此外，如果镜像构建时，定义了 LABEL，还可以通过 LABEL 来过滤。  1  $ docker image ls -f label=com.example.version=0.1   删除本地镜像 1  $ docker image rm [选项] \u0026lt;镜像1\u0026gt; [\u0026lt;镜像2\u0026gt; ...]   使用Dockerfile定制镜像 镜像的定制实际上就是定制每一层所添加的配置、文件。如果我们可以把每一层修改、安装、构建、操作的命令都写入一个脚本，用这个脚本来构建、定制镜像，那么之前提及的无法重复的问题、镜像构建透明性的问题、体积的问题就都会解决。这个脚本就是 Dockerfile。\nDockerfile 是一个文本文件，其内包含了一条条的 指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。\n1 2 3 4 5 6  $ mkdir mynginx $ cd mynginx $ touch Dockerfile FROM nginx RUN echo \u0026#39;\u0026lt;h1\u0026gt;Hello, Docker!\u0026lt;/h1\u0026gt;\u0026#39; \u0026gt; /usr/share/nginx/html/index.html   这个 Dockerfile 很简单，一共就两行。涉及到了两条指令，FROM 和 RUN。\nFROM 指定基础镜像 所谓定制镜像，那一定是以一个镜像为基础，在其上进行定制。就像我们之前运行了一个 nginx 镜像的容器，再进行修改一样，基础镜像是必须指定的。而 FROM 就是指定 基础镜像，因此一个 Dockerfile 中 FROM 是必备的指令，并且必须是第一条指令。\nBUILD 构建镜像 1  docker build [选项] \u0026lt;上下文路径/URL/-\u0026gt;     镜像构建上下文（Context）\n如果注意，会看到 docker build 命令最后有一个 . 表示当前目录，而 Dockerfile 就在当前目录，因此不少初学者以为这个路径是在指定 Dockerfile 所在路径，这么理解其实是不准确的。如果对应上面的命令格式，你可能会发现，这是在指定上下文路径。那么什么是上下文呢？\n  当我们进行镜像构建的时候，并非所有定制都会通过 RUN 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 COPY 指令、ADD 指令等。而 docker build 命令构建镜像，其实并非在本地构建，而是在服务端，也就是 Docker 引擎中构建的。那么在这种客户端/服务端的架构中，如何才能让服务端获得本地文件呢？\n  这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。\n  如果在 Dockerfile 中这么写：\nCOPY ./package.json /app/\n这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制 上下文（context） 目录下的 package.json。\n因此，COPY 这类指令中的源文件的路径都是相对路径。这也是初学者经常会问的为什么 COPY ../package.json /app 或者 COPY /opt/xxxx /app 无法工作的原因，因为这些路径已经超出了上下文的范围，Docker 引擎无法获得这些位置的文件。如果真的需要那些文件，应该将它们复制到上下文目录中去。\n现在就可以理解刚才的命令 docker build -t nginx:v3 . 中的这个 . 实际上是在指定上下文的目录，docker build 命令会将该目录下的内容打包交给 Docker 引擎以帮助构建镜像。\n如果观察 docker build 输出，我们其实已经看到了这个发送上下文的过程：\n1 2 3  $ docker build -t nginx:v3 . Sending build context to Docker daemon 2.048 kB ...   理解构建上下文对于镜像构建是很重要的，避免犯一些不应该的错误。比如有些初学者在发现 COPY /opt/xxxx /app 不工作后，于是干脆将 Dockerfile 放到了硬盘根目录去构建，结果发现 docker build 执行后，在发送一个几十 GB 的东西，极为缓慢而且很容易构建失败。那是因为这种做法是在让 docker build 打包整个硬盘，这显然是使用错误。\n一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。\n那么为什么会有人误以为 . 是指定 Dockerfile 所在目录呢？这是因为在默认情况下，如果不额外指定 Dockerfile 的话，会将上下文目录下的名为 Dockerfile 的文件作为 Dockerfile。\n这只是默认行为，实际上 Dockerfile 的文件名并不要求必须为 Dockerfile，而且并不要求必须位于上下文目录中，比如可以用 -f ../Dockerfile.php 参数指定某个文件作为 Dockerfile。\n当然，一般大家习惯性的会使用默认的文件名 Dockerfile，以及会将其置于镜像构建上下文目录中。\n","description":"Docker的使用方式","id":2,"section":"posts","tags":[""],"title":"[Docker详解]-2:Docker的使用","uri":"https://zhr619151879.github.io/posts/series/docker/%E6%8F%AD%E7%A7%98docker-2/"},{"content":"什么是Docker Docker:    runc 是一个 Linux 命令行工具，用于根据 OCI容器运行时规范 (opens new window)创建和运行容器。\ncontainerd 是一个守护程序，它管理容器生命周期，提供了在一个节点上执行容器和管理镜像的最小功能集。\n  Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。使得 Docker 技术比虚拟机技术更为轻便、快捷。  下面的图片比较了 Docker 和传统虚拟化方式的不同之处。传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程\n而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。\nDocker:   为什么要使用Docker  作为一种新兴的虚拟化方式，Docker 跟传统的虚拟化方式相比具有众多的优势。  更高效的利用系统资源  由于容器不需要进行硬件虚拟以及运行完整操作系统等额外开销，Docker 对系统资源的利用率更高。无论是应用执行速度、内存损耗或者文件存储速度，都要比传统虚拟机技术更高效。因此，相比虚拟机技术，一个相同配置的主机，往往可以运行更多数量的应用。\n 更快速的启动时间  传统的虚拟机技术启动应用服务往往需要数分钟，而 Docker 容器应用，由于直接运行于宿主内核，无需启动完整的操作系统，因此可以做到秒级、甚至毫秒级的启动时间。大大的节约了开发、测试、部署的时间。\n 一致的运行环境  开发过程中一个常见的问题是环境一致性问题。由于开发环境、测试环境、生产环境不一致，导致有些 bug 并未在开发过程中被发现。而 Docker 的镜像提供了除内核外完整的运行时环境，确保了应用运行环境一致性，从而不会再出现 「这段代码在我机器上没问题啊」 这类问题。\n 持续交付和部署  对开发和运维（DevOps ）人员来说，最希望的就是一次创建或配置，可以在任意地方正常运行。\n  使用 Docker 可以通过定制应用镜像来实现持续集成、持续交付、部署。开发人员可以通过 Dockerfile 来进行镜像构建，并结合 持续集成(Continuous Integration) (opens new window)系统进行集成测试，而运维人员则可以直接在生产环境中快速部署该镜像，甚至结合 持续部署(Continuous Delivery/Deployment) (opens new window)系统进行自动部署。\n  而且使用 Dockerfile 使镜像构建透明化，不仅仅开发团队可以理解应用运行环境，也方便运维团队理解应用运行所需条件，帮助更好的生产环境中部署该镜像。\n 更轻松的迁移  由于 Docker 确保了执行环境的一致性，使得应用的迁移更加容易。Docker 可以在很多平台上运行，无论是物理机、虚拟机、公有云、私有云，甚至是笔记本，其运行结果是一致的。因此用户可以很轻易的将在一个平台上运行的应用，迁移到另一个平台上，而不用担心运行环境的变化导致应用无法正常运行的情况。\n 更轻松的维护和扩展  Docker 使用的分层存储以及镜像的技术，使得应用重复部分的复用更为容易，也使得应用的维护更新更加简单，基于基础镜像进一步扩展镜像也变得非常简单。此外，Docker 团队同各个开源项目团队一起维护了一大批高质量的 官方镜像 (opens new window)，既可以直接在生产环境使用，又可以作为基础进一步定制，大大的降低了应用服务的镜像制作成本。\n 对比传统虚拟机总结    特性 容器 虚拟机     启动 秒级 分钟级   硬盘使用 MB GB   性能 接近原生 弱   系统支持量(单机) 上千 几十    Docker基本概念 基本概念 Docker 包括三个基本概念\n 镜像（Image） 容器（Container） 仓库（Repository）  理解了这三个概念，就理解了 Docker 的整个生命周期。\nDocker镜像  我们都知道，操作系统分为内核和用户空间。对于 Linux 而言，内核启动后，会挂载root 文件系统为其提供用户空间支持。而 Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。\nDocker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\n Docker容器 镜像（Image和容器（Container）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。\n 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。\n容器不应该向其存储层内写入任何数据，容器存储层要保持无状态化。所有的文件写入操作，都应该使用数据卷（Volume）、或者绑定宿主目录，在这些位置的读写会跳过容器存储层，直接对宿主（或网络存储）发生读写，其性能和稳定性更高。\n数据卷的生存周期独立于容器，容器消亡，数据卷不会消亡。因此，使用数据卷后，容器删除或者重新运行之后，数据却不会丢失。\n Docker Registry  镜像构建完成后，可以很容易的在当前宿主机上运行，但是，如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry 就是这样的服务。  一个 Docker Registry 中可以包含多个 仓库（Repository）；每个仓库可以包含多个 标签（Tag）；每个标签对应一个镜像。\n 通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 \u0026lt;仓库名\u0026gt;:\u0026lt;标签\u0026gt; 的格式来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。\n以 Ubuntu 镜像为例，ubuntu 是仓库的名字，其内包含有不同的版本标签，如，16.04, 18.04。我们可以通过 ubuntu:16.04，或者 ubuntu:18.04 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 ubuntu，那将视为 ubuntu:latest。\n仓库名经常以 两段式路径 形式出现，比如 jwilder/nginx-proxy，前者往往意味着 Docker Registry 多用户环境下的用户名，后者则往往是对应的软件名。但这并非绝对，取决于所使用的具体 Docker Registry 的软件或服务。\n Docker Registry 公开服务 Docker Registry 公开服务是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。\n最常使用的 Registry 公开服务是官方的 Docker Hub ，这也是默认的 Registry，并拥有大量的高质量的官方镜像。除此以外，还有 Red Hat 的 Quay.io ；Google 的 Google Container Registry，Kubernetes的镜像使用的就是这个服务。\n由于某些原因，在国内访问这些服务可能会比较慢。国内的一些云服务商提供了针对 Docker Hub 的镜像服务（Registry Mirror），这些镜像服务被称为 加速器。常见的有 阿里云加速器 、DaoCloud 加速器等。使用加速器会直接从国内的地址下载 Docker Hub 的镜像，比直接从 Docker Hub 下载速度会提高很多。在 安装 Docker 一节中有详细的配置方法。\n国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 网易云镜像服务、DaoCloud 镜像市场 、阿里云镜像库 等。\n","description":"DOCKER","id":3,"section":"posts","tags":[""],"title":"[Docker详解]-1:初探Docker","uri":"https://zhr619151879.github.io/posts/series/docker/%E6%8F%AD%E7%A7%98docker-1/"},{"content":"概述 基础 数据类型(字节 1byte=8bits)  byte/1 char/2 short/2 int/4 float/4 long/8 double/8 boolean/~ : true、false，可以使用 1 bit 来存储，但是具体大小没有明确规定。JVM 会在编译时期将 boolean 类型的数据转换为 int，使用 1 来表示 true，0 表示 false。JVM 支持 boolean 数组，但是是通过读写 byte 数组来实现的。  包装类型 基本类型都有对应的包装类型，基本类型与其对应的包装类型之间的赋值使用自动装箱与拆箱完成。(包装类相当于基本类型的缓存)\n1 2  Integer x = 2; // 装箱 调用了 Integer.valueOf(2) int y = x; // 拆箱 调用了 X.intValue()   ![image-20200828100722898](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200828100722898.png)\n缓存池 new Integer(123) 与 Integer.valueOf(123) 的区别在于：\n new Integer(123) 每次都会新建一个对象； Integer.valueOf(123) 会使用缓存池中的对象，多次调用会取得同一个对象的引用。 ![image-20200820222714502](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820222714502.png)    ![image-20200811181120345](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200811181120345.png)\n   JVM中一个字节以下的整型数据（即[-128,127]）会在JVM启动时加载进内存，所以除非用new Integer()显示的创建对象，否则都是同一对象.\n   String(引用类型) String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）\nStringPool ![image-20200820224103405](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820224103405.png)\n 如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。  ![image-20200820222953658](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820222953658.png)\nStringBuffer StringBuilder 1. 可变性\n String 不可变 StringBuffer 和 StringBuilder 可变  2. 线程安全\n String 不可变，因此是线程安全的 StringBuilder 不是线程安全的 StringBuffer 是线程安全的，内部使用 synchronized 进行同步  关键字 Final 1. 数据\n声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。\n 对于基本类型，final 使数值不变； 对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。  1 2 3 4  final int x = 1; // x = 2; // cannot assign value to final variable \u0026#39;x\u0026#39; final A y = new A(); y.a = 1;   2. 方法\n声明方法不能被子类重写。\nprivate 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。\n3. 类\n声明类不允许被继承。\nStatic 1. 静态变量\n 静态变量：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。 实例变量：每创建一个实例就会产生一个实例变量，它与该实例同生共死。  2. 静态方法\n静态方法在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。\n3. 静态语句块\n静态语句块在类初始化时运行一次。\n4. 静态内部类\n非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。\n静态内部类不能访问外部类的非静态的变量和方法。\n![image-20200820224711474](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820224711474.png)\nObject常用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  public native int hashCode() public boolean equals(Object obj) protected native Object clone() throws CloneNotSupportedException public String toString() public final native Class\u0026lt;?\u0026gt; getClass() protected void finalize() throws Throwable {} public final native void notify() public final native void notifyAll() public final native void wait(long timeout) throws InterruptedException public final void wait(long timeout, int nanos) throws InterruptedException public final void wait() throws InterruptedException    equal():  ![image-20200820225846600](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820225846600.png)\nClone()\n 浅拷贝: 拷贝的对象是同一引用 深拷贝: 不同引用  接口与抽象类 ![image-20200820231226200](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820231226200.png)\n 从设计层面上看，抽象类提供了一种 IS-A 关系，需要满足里式替换原则，即子类对象必须能够替换掉所有父类对象。而接口更像是一种 LIKE-A 关系，它只是提供一种方法实现契约，并不要求接口和实现接口的类具有 IS-A 关系。 从使用上来看，一个类可以实现多个接口，但是不能继承多个抽象类。 接口的字段只能是 static 和 final 类型的，而抽象类的字段没有这种限制。 接口的成员只能是 public 的，而抽象类的成员可以有多种访问权限。  反射 反射机制是在运行时，对于任意一个类，都能够知道这个类的所有属性和方法;对于任意个对象，都能 够调用它的任意一个方法。在java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。\n 这种动态获取的信息以及动态调用对象的方法的功能称为反射机制 反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。  ![image-20200821102113144](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200821102113144.png)\n![image-20200821102154776](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200821102154776.png)\n反射的实现:\n![image-20200820235351122](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820235351122.png)\n Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段； Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法； Constructor ：可以用 Constructor 的 newInstance() 创建新的对象。  动态代理\n![image-20200821100253857](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200821100253857.png)\n动态代理类是JVM运行时根据字节码文件动态生成的\n![image-20200821102900523](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200821102900523.png)\n序列化 序列化就是将一个对象转换成字节序列，方便存储和传输。\n 序列化：ObjectOutputStream.writeObject() 反序列化：ObjectInputStream.readObject()  不会对静态变量进行序列化，因为序列化只是保存对象的状态，静态变量属于类的状态。\n 序列化的类需要实现 Serializable 接口，它只是一个标准，没有任何方法需要实现，但是如果不去实现它的话而进行序列化，会抛出异常。  transient 关键字可以使一些属性不会被序列化。\nArrayList 中存储数据的数组 elementData 是用 transient 修饰的，因为这个数组是动态扩展的，并不是所有的空间都被使用，因此就不需要所有的内容都被序列化。通过重写序列化和反序列化方法，使得可以只序列化数组中有内容的那部分数据。\n1  private transient Object[] elementData;   NIO ![image-20200821104411260](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200821104411260.png)\n![image-20200821104615692](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200821104615692.png)\n容器 容器主要包括 Collection 和 Map 两种，Collection 存储着对象的集合，而 Map 存储着键值对（两个对象）的映射表。\n Collection  ![image-20200821104703125](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200821104703125.png)\n Map  ![image-20200821104805067](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200821104805067.png)\nArrayList ![image-20200821105056451](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200821105056451.png)\n![image-20200821105117209](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200821105117209.png)\n Vector的实现与ArrayList相似,但是使用了synchronize.  CopyOnWriteArrayList  读写分离  写操作在一个复制的数组上进行，读操作还是在原始数组中进行，读写分离，互不影响。\n写操作需要加锁，防止并发写入时导致写入数据丢失。\n写操作结束之后需要把原始数组指向新的复制数组。\nCopyOnWriteArrayList 在写操作的同时允许读操作，大大提高了读操作的性能，因此很适合读多写少的应用场景。\n![image-20200911165421238](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200911165421238.png)\nHashMap ![image-20200821105917227](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200821105917227.png)\n 插入时使用头插法(倒序)  ![image-20200831154118850](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200831154118850.png)\n为什么HashMap线程不安全  PUT插入数据时 数据不一致(覆盖)  ![image-20200831150210178](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200831150210178.png)\n 扩容时死循环  当两个线程都扩容时, 会出现环形链表, CPU100%\n![image-20200831155245319](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200831155245319.png)\n![image-20200831155636743](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200831155636743.png)\n 在JDK1.8中, 使用了尾插法, 不会出现环型链表.会出现数据覆盖  HashTable  HashTable使用Synchronize进行 默认长度为11 扩容: 11*2 + 1, 因为分散性更高  HashTable 直接使用 hashCode(Key)\n而 HashMap:使用hash再一次分散 (前十位异或后十二位)\nhash( key.hasCode() )\nConcurrentHashMap  1.7  ConcurrentHashMap 和 HashMap 实现上类似，最主要的差别是 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高（并发度就是 Segment 的个数）。\n(默认16个segment, 即16并发数)\n![image-20200821111606289](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200821111606289.png)\nConcurrentHashMap 在默认并发级别会创建包含 16 个 Segment 对象的数组。每个 Segment 的成员对象 table 包含若干个散列表的桶。每个桶是由 HashEntry 链接起来的一个链表。如果键能均匀散列，每个 Segment 大约守护整个散列表中桶总数的 1/16。\n![image-20200824140746639](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824140746639.png)\n![image-20200824144248901](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824144248901.png)\n(当删除时会建立一条新的链表(倒序), 不会干扰别的进程读)\n 1.8 JDK 1.8 使用了 CAS 操作来支持更高的并发度，在 CAS 操作失败时使用内置锁 synchronized。(颗粒度变为Node)  ![image-20200824145213444](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824145213444.png)\n![image-20200824145244761](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824145244761.png)\n并发 基础线程机制  Executor   Executor 管理多个异步任务的执行，而无需程序员显式地管理线程的生命周期。这里的异步是指多个任务的执行互不干扰，不需要进行同步操作。\n ![image-20200822155219858](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822155219858.png)\n Daemon   守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。\n当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。\nmain() 属于非守护线程。\n在线程启动之前使用 setDaemon() 方法可以将一个线程设置为守护线程。\n 1 2 3 4  public static void main(String[] args) { Thread thread = new Thread(new MyRunnable()); thread.setDaemon(true); }    sleep()  Thread.sleep(millisec) 方法会休眠当前正在执行的线程，millisec 单位为毫秒。\nsleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理。\n yield()  对静态方法 Thread.yield() 的调用声明了当前线程已经完成了生命周期中最重要的部分，可以切换给其它线程来执行。该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行。\n![image-20200822155512164](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822155512164.png)\n线程池 Executors构造 Java中创建线程池很简单，只需要调用Executors中相应的便捷方法即可，比如Executors.newFixedThreadPool(int nThreads)，但是便捷不仅隐藏了复杂性，也为我们埋下了潜在的隐患（OOM，线程耗尽）。\nExecutors创建线程池便捷方法列表：\n   方法名 功能     newFixedThreadPool(int nThreads) 创建固定大小的线程池   newSingleThreadExecutor() 创建只有一个线程的线程池   newCachedThreadPool() 创建一个不限线程数上限的线程池，任何提交的任务都将立即执行    ThreadPoolExecutor构造 ![image-20200901091651047](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200901091651047.png)\n![image-20200901103223869](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200901103223869.png)\n四种拒绝策略 ![image-20200901094608378](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200901094608378.png)\n互斥同步 synchronized  只作用于同一个对象,如果调用两个对象上的同步代码块,则不起作用.  同步一个方法:\n1 2 3  public synchronized void func () { // ... }   它只作用于同一个对象，如果调用两个对象上的同步代码块，就不会进行同步。\n对于以下代码，使用 ExecutorService 执行了两个线程，由于调用的是同一个对象的同步代码块，因此这两个线程会进行同步，当一个线程进入同步语句块时，另一个线程就必须等待。\n![image-20200822160559053](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822160559053.png)\n![image-20200822160920850](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822160920850.png)\n同步一个类 ( 同步一个静态方法也是作用于整个类)\n![image-20200822161120210](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822161120210.png)\nJDK1.7 1.8 区别:\nRentrantLock ReentrantLock 是 java.util.concurrent（J.U.C）包中的锁。\n![image-20200822162026639](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822162026639.png)\n比较\n 1. 锁的实现\nsynchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。\n2. 性能\n新版本 Java 对 synchronized 进行了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致相同。\n3. 等待可中断\n当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。\nReentrantLock 可中断，而 synchronized 不行。\n4. 公平锁\n公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。\nsynchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。\n5. 锁绑定多个条件\n一个 ReentrantLock 可以同时绑定多个 Condition 对象。\n 除非需要使用 ReentrantLock 的高级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地支持它，而 ReentrantLock 不是所有的 JDK 版本都支持。并且使用 synchronized 不用担心没有释放锁而导致死锁问题，因为 JVM 会确保锁的释放。\n非阻塞同步(CAS) ![image-20200822171725583](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822171725583.png)\n1. CAS 乐观锁需要操作和冲突检测这两个步骤具备原子性，这里就不能再使用互斥同步来保证了，只能靠硬件来完成。硬件支持的原子性操作最典型的是：比较并交换（Compare-and-Swap，CAS）。CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。\n java中  ![image-20200824101810547](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824101810547.png)\n![image-20200824101907397](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824101907397.png)\n 不足: ABA问题, 自选CPU占用大, 只能对一个原子共享变量生效.  2. AtomicInteger J.U.C 包里面的整数原子类 AtomicInteger 的方法调用了 Unsafe 类的 CAS 操作。\n无同步方案 线程本地存储（Thread Local Storage） ![image-20200822172143095](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822172143095.png)\n![image-20200822172255467](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822172255467.png)\n为了理解 ThreadLocal，先看以下代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  public class ThreadLocalExample1 { public static void main(String[] args) { ThreadLocal threadLocal1 = new ThreadLocal(); ThreadLocal threadLocal2 = new ThreadLocal(); Thread thread1 = new Thread(() -\u0026gt; { threadLocal1.set(1); threadLocal2.set(1); }); Thread thread2 = new Thread(() -\u0026gt; { threadLocal1.set(2); threadLocal2.set(2); }); thread1.start(); thread2.start(); } }   它所对应的底层结构图为：\n![image-20200822173256305](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822173256305.png)\n每个 Thread 都有一个 ThreadLocal.ThreadLocalMap 对象。\n1 2 3  /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null;   当调用一个 ThreadLocal 的 set(T value) 方法时，先得到当前线程的 ThreadLocalMap 对象，然后将 ThreadLocal-\u0026gt;value 键值对插入到该 Map 中。\n1 2 3 4 5 6 7 8  public void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); }   get() 方法类似。\n1 2 3 4 5 6 7 8 9 10 11 12 13  public T get() { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) { ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) T result = (T)e.value; return result; } } return setInitialValue(); }   ThreadLocal 从理论上讲并不是用来解决多线程并发问题的，因为根本不存在多线程竞争。\n在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险。\n 主要用途是数据隔离.  ![image-20200824114612152](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824114612152.png)\n线程协作  join()  在线程中调用另一个线程的 join() 方法，会将当前线程挂起，而不是忙等待，直到目标线程结束。\n对于以下代码，虽然 b 线程先启动，但是因为在 b 线程中调用了 a 线程的 join() 方法，b 线程会等待 a 线程结束才继续执行，因此最后能够保证 a 线程的输出先于 b 线程的输出。\n wait() notify() notifyAll()  调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。\n它们都属于 Object 的一部分，而不属于 Thread。\n只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。\n使用 wait() 挂起期间，线程会释放锁。这是因为，如果没有释放锁，那么其它线程就无法进入对象的同步方法或者同步控制块中，那么就无法执行 notify() 或者 notifyAll() 来唤醒挂起的线程，造成死锁。\n![image-20200822163106609](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822163106609.png)\nwait() 和 sleep() 的区别\n wait() 是 Object 的方法，而 sleep() 是 Thread 的静态方法；\nwait() 会释放锁，sleep() 不会。\n  await() signal() signalAll()  java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。\n相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。\n使用 Lock 来获取一个 Condition 对象。\n![image-20200822163856945](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822163856945.png)\nwait() 和 notify() 是 Object的方法, 只能用在同步方法或者同步控制块中使用，否则会在运行时抛出 IllegalMonitorStateException。\n而await() 和 signal() 是JUC的方法.\n线程状态 新建（NEW） 创建后尚未启动。\n可运行（RUNABLE） 正在 Java 虚拟机中运行。但是在操作系统层面，它可能处于运行状态，也可能等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指可以被运行，具体有没有运行要看底层操作系统的资源调度。\n阻塞（BLOCKED） 请求获取 monitor lock 从而进入 synchronized 函数或者代码块，但是其它线程已经占用了该 monitor lock，所以出于阻塞状态。要结束该状态进入从而 RUNABLE 需要其他线程释放 monitor lock。\n无限期等待（WAITING） 等待其它线程显式地唤醒。\n阻塞和等待的区别在于，阻塞是被动的，它是在等待获取 monitor lock。而等待是主动的，通过调用 Object.wait() 等方法进入。\n   进入方法 退出方法     没有设置 Timeout 参数的 Object.wait() 方法 Object.notify() / Object.notifyAll()   没有设置 Timeout 参数的 Thread.join() 方法 被调用的线程执行完毕   LockSupport.park() 方法 LockSupport.unpark(Thread)    限期等待（TIMED_WAITING） 无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。\n   进入方法 退出方法     Thread.sleep() 方法 时间结束   设置了 Timeout 参数的 Object.wait() 方法 时间结束 / Object.notify() / Object.notifyAll()   设置了 Timeout 参数的 Thread.join() 方法 时间结束 / 被调用的线程执行完毕   LockSupport.parkNanos() 方法 LockSupport.unpark(Thread)   LockSupport.parkUntil() 方法 LockSupport.unpark(Thread)    调用 Thread.sleep() 方法使线程进入限期等待状态时，常常用“使一个线程睡眠”进行描述。调用 Object.wait() 方法使线程进入限期等待或者无限期等待时，常常用“挂起一个线程”进行描述。睡眠和挂起是用来描述行为，而阻塞和等待用来描述状态。\n死亡（TERMINATED） 可以是线程结束任务之后自己结束，或者产生了异常而结束。\nAQS(重点) AQS原理\nAQS：AbstractQuenedSynchronizer抽象的队列式同步器。是除了java自带的synchronized关键字之外的锁机制。\nAQS的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包\n![image-20200824105159830](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824105159830.png)\n![image-20200824104543189](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824104543189.png)\n![image-20200824105522949](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824105522949.png)\n![image-20200824110554272](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824110554272.png)\nReentrantLock为例，（可重入独占式锁）：state初始化为0，表示未锁定状态，A线程lock()时，会调用tryAcquire()独占锁并将state+1.之后其他线程再想tryAcquire的时候就会失败，直到A线程unlock（）到state=0为止，其他线程才有机会获取该锁。A释放锁之前，自己也是可以重复获取此锁（state累加），这就是可重入的概念。\n注意：获取多少次锁就要释放多少次锁，保证state是能回到零态的。\n以CountDownLatch为例，任务分N个子线程去执行，state就初始化 为N，N个线程并行执行，每个线程执行完之后countDown（）一次，state就会CAS减一。当N子线程全部执行完毕，state=0，会unpark()主调用线程，主调用线程就会从await()函数返回，继续之后的动作。\n一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。\n在acquire() acquireShared()两种方式下，线程在等待队列中都是忽略中断的，acquireInterruptibly()/acquireSharedInterruptibly()是支持响应中断的。\n![image-20200824112723607](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824112723607.png)\nCountDownLatch(share型方法,非独占) ![image-20200822165239917](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822165239917.png)\nCyclicBarrier 用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。\n和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行 await() 方法之后计数器会减 1，并进行等待，直到计数器为 0，所有调用 await() 方法而在等待的线程才能继续执行。\nCyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。\nCyclicBarrier 有两个构造函数，其中 parties 指示计数器的初始值，barrierAction 在所有线程都到达屏障的时候会执行一次。\njava内存模型 ![image-20200822170434251](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822170434251.png)\n 所有的变量都存储在主内存中，每个线程还有自己的工作内存，工作内存存储在高速缓存或者寄存器中，保存了该线程使用的变量的主内存副本拷贝。\n线程只能直接操作工作内存中的变量，不同线程之间的变量值传递需要通过主内存来完成\n ![image-20200822170542843](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822170542843.png)\n![image-20200822170558601](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822170558601.png)\n read：把一个变量的值从主内存传输到工作内存中 load：在 read 之后执行，把 read 得到的值放入工作内存的变量副本中 use：把工作内存中一个变量的值传递给执行引擎 assign：把一个从执行引擎接收到的值赋给工作内存的变量 store：把工作内存的一个变量的值传送到主内存中 write：在 store 之后执行，把 store 得到的值放入主内存的变量中 lock：作用于主内存的变量 unlock  可见性\n可见性指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值来实现可见性的。\n主要有三种实现可见性的方式：\n volatile synchronized，对一个变量执行 unlock 操作之前，必须把变量值同步回主内存。 final，被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 逃逸（其它线程通过 this 引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。  对前面的线程不安全示例中的 cnt 变量使用 volatile 修饰，不能解决线程不安全问题，因为 volatile 并不能保证操作的原子性。\nVolatile ![image-20200828095219798](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200828095219798.png)\n volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存 volatile读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。  ![image-20200828100228720](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200828100228720.png)\n Volatile 保证了共享变量的可见性  为什么volatile能够保证变量在线程中的可见性？因为JVM就是通过volatile调动了缓存一致性机制，如果对使用了volatile的程序，查看JVM解释执行或者JIT编译后生成的汇编代码，你会发现对volatile域（被volatile修饰的共享变量）的写操作生成的汇编指令会有一个lock前缀，该lock前缀表示JVM会向CPU发送一个信号，这个信号有两个作用：\n 对该变量的改写立即刷新到主存（也就是说对volatile域的写会导致assgin -\u0026gt; store -\u0026gt; write的原子性执行） 通过总线通知其他CPU该共享变量已被更新，对于也缓存了该共享变量的CPU，如果接收到该通知，那么会在自己的Cache中将共享变量所在的缓存行置为无效状态。CPU在下次读取读取该共享变量时发现缓存行已被置为无效状态，他将重新到主存中读取。  锁优化(synchronize) ![image-20200823144147644](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200823144147644.png)\n 重量级锁  ![image-20200823144207693](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200823144207693.png)\n 自旋锁  通过自旋锁，可以减少线程阻塞造成的线程切换（包括挂起线程和恢复线程）。\n互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。\n自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。\n在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。\n 锁消除 锁粗化  ![image-20200822174659637](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822174659637.png)\n 轻量级锁  解决无竞争还要争夺锁(重量级) 的问题\n![image-20200823144848186](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200823144848186.png)\n![image-20200822175309239](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822175309239.png)\n 偏向锁  ![image-20200822175526792](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200822175526792.png)\nJVM i++ 与 ++i ![image-20200824102203181](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824102203181.png)\n![image-20200824102052518](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824102052518.png)\nJVM 结构  程序计数器  记录正在执行的虚拟机字节码指令的地址（如果正在执行的是本地方法则为空）。\n Java虚拟机栈  每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。\n![image-20200824175804617](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824175804617.png)\n 本地方法栈  ![image-20200824175850249](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824175850249.png)\n 堆  所有对象都在这里分配内存，是垃圾收集的主要区域（\u0026ldquo;GC 堆\u0026rdquo;）。\n现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。可以将堆分成两块：\n 新生代（Young Generation） 老年代（Old Generation）  堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常\n 方法区  ![image-20200824180045747](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824180045747.png)\n 运行时常量池  运行时常量池是方法区的一部分。\nClass 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。\n除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。\nJDK1.8 ![image-20200825102016776](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825102016776.png)\n在永久代移除后，字符串常量池也不再放在永久代了，但是也没有放到新的方法区\u0026mdash;元空间里，而是留在了堆里（为了方便回收？）。运行时常量池当然是随着搬家到了元空间里，毕竟它是装类的重要信息的，有它的地方才称得上是方法区。\n![image-20200825102416330](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825102416330.png)\nclass常量池\n字面量 包括：1.文本字符串 2.八种基本类型的值 3.被声明为final的常量等;\n方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中\n对象 对象创建 ![image-20200923095324534](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200923095324534.png)\n为什么单例模式的DoubleCheckedLocking中要使用Violate ​\t因为创建对象的过程很复杂, 很有可能在重排序之后导致对象的引用被返回了而对象的初始化并未完成, 会导致难以理解的空指针异常.\n对象内存布局 ![image-20200923095906461](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200923095906461.png)\n对象死亡回收 ![image-20200923145427349](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200923145427349.png)\n垃圾收集 垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。\n判断对象是否可被回收 引用计数 为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。\n在两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。正是因为循环引用的存在，因此 Java 虚拟机不使用引用计数算法。\n可达性分析 以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。\nJava 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：\n 虚拟机栈中局部变量表中引用的对象 本地方法栈中 JNI 中引用的对象 方法区中类静态属性引用的对象 方法区中的常量引用的对象  ![image-20200824180738138](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824180738138.png)\n方法区回收 因为方法区主要存放永久代对象，而永久代对象的回收率比新生代低很多，所以在方法区上进行回收性价比不高。\n主要是对常量池的回收和对类的卸载。\n为了避免内存溢出，在大量使用反射和动态代理的场景都需要虚拟机具备类卸载功能。\n类的卸载条件很多，需要满足以下三个条件，并且满足了条件也不一定会被卸载：\n 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例。 加载该类的 ClassLoader 已经被回收。 该类对应的 Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法  引用类型 Java 提供了四种强度不同的引用类型。\n 强引用  被强引用关联的对象不会被回收。\n使用 new 一个新对象的方式来创建强引用。\n 软引用  被软引用关联的对象只有在内存不够的情况下才会被回收。\n使用 SoftReference 类来创建软引用。\n 弱引用  被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。\n使用 WeakReference 类来创建弱引用。\n 虚引用  又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。\n为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。\n使用 PhantomReference 来创建虚引用。\n垃圾收集算法(GC算法) 标记-清除 ![image-20200825103557334](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825103557334.png)\n标记-整理 ![image-20200825103632169](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825103632169.png)\n复制 ![image-20200825103710396](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825103710396.png)\n分代收集 现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。\n一般将堆分为新生代和老年代。\n  新生代使用：复制算法\n  老年代使用：标记 - 清除 或者 标记 - 整理 算法\n  Minor GC\n因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。\n![image-20200825111618783](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825111618783.png)\nFullGC\n回收老年代和新生代，老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。\n分代收集(generation collection)\n![image-20200825111756191](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825111756191.png)\n内存分配策略 ![image-20200827162554769](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200827162554769.png)\n![image-20200827163040285](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200827163040285.png)\n15岁进入老年代\n![image-20200825112106156](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825112106156.png)\n![image-20200923162007531](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200923162007531.png)\nFull GC 触发条件 ![image-20200825112200407](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825112200407.png)\n收集器  吞吐量: CPU 用于运行用户程序的时间占总时间的比值  ![image-20200825112956120](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825112956120.png)\n 单线程与多线程：单线程指的是垃圾收集器只使用一个线程，而多线程使用多个线程； 串行与并行：串行指的是垃圾收集器与用户程序交替执行，这意味着在执行垃圾收集的时候需要停顿用户程序；并行指的是垃圾收集器和用户程序同时执行。除了 CMS 和 G1 之外，其它垃圾收集器都是以串行的方式执行  1. Serial 收集器 ![image-20200825113313599](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825113313599.png)\nSerial 翻译为串行，也就是说它以串行的方式执行。\n它是单线程的收集器，只会使用一个线程进行垃圾收集工作。\n它的优点是简单高效，在单个 CPU 环境下，由于没有线程交互的开销，因此拥有最高的单线程收集效率。\n它是 Client 场景下的默认新生代收集器，因为在该场景下内存一般来说不会很大。它收集一两百兆垃圾的停顿时间可以控制在一百多毫秒以内，只要不是太频繁，这点停顿时间是可以接受的。\n2.ParNew收集器 ![image-20200825113343165](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825113343165.png)\n它是 Serial 收集器的多线程版本。\n它是 Server 场景下默认的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合使用。\n3. Parallel Scavenge ![image-20200825113621429](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825113621429.png)\n4. CMS收集器 是一种以获取最短回收停顿时间为目标的收集器，它非常符合那些集中在互联网站或者B/S系统的服务端上的Java应用，这些应用都非常重视服务的响应速度。\n![image-20200825113753976](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825113753976.png)\n 初始标记（CMS initial mark）：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。 并发标记（CMS concurrent mark）：进行GC Roots Tracing的过程，在整个过程中耗时最长。 重新标记（CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。 并发清除（CMS concurrent sweep）  优点\nCMS是一款优秀的收集器，它的主要优点在名字上已经体现出来了：并发收集、低停顿，因此CMS收集器也被称为并发低停顿收集器（Concurrent Low Pause Collector）。\n缺点\n![image-20200825114041062](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825114041062.png)\n5.G1收集器 G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。\n![image-20200825115310204](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825115310204.png)\n![image-20200825115414799](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825115414799.png)\n![image-20200825115539147](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825115539147.png)\n![image-20200825114757525](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825114757525.png)\n类加载机制 类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。\n类的生命周期 ![image-20200825104239996](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825104239996.png)\n类加载过程 包含了加载、验证、准备、解析和初始化这 5 个阶段。\n![image-20200825143340915](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825143340915.png)\n 加载  ![image-20200825104451499](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825104451499.png)\n 验证  确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。\n 准备  ![image-20200825104635015](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825104635015.png)\n 解析  将常量池的符号引用替换为直接引用的过程。\n其中解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。\n 初始化  初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 () 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。\n初始化时机\n![image-20200825105854030](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825105854030.png)\n![image-20200825105950831](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825105950831.png)\n双亲委派机制: 加载类时, 先由parent加载器解决, 不行再回传\n bootstrap加载器: java, javax, sun.xx lib 包的类加载 extension加载器: ext 加载器 application加载器: 用户diy类加载  优点:\n减少类重复加载\n防止攻击\nSpring  循环依赖是什么, Spring怎么解决(三级缓存)  ![image-20200828091051841](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200828091051841.png)\n![image-20200828091401020](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200828091401020.png)\n Spring设计模式  工厂: Bean工厂, applicationContext: 一次性加载, beanfactory : 延迟加载\n代理: AOP\n适配器: SpringMVC\n单例: Bean(singleton)\n面试 内存溢出OOM(outOfMemory) 排查\n 堆溢出 元空间溢出 栈溢出  使用工具: MAT, VisualVM\nEclipse MAT(Memory Analyzer Tool)\n 排查过程  ![image-20200913095412846](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200913095412846.png)\n![image-20200913095645905](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200913095645905.png)\nIO流使用的设计模式\n ![image-20200826151218500](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200826151218500.png)  Maven中dependencies与dependencyManagement的区别\n management管理全局依赖, 子模块只需要输入parent, 不需要版本号,统一管理 如果要不同版本号, 只需在对应的dependencies修改即可  如何从大量的两个文件中找出相同的xxx?\n 一般都是分治策略. 将文件A的url按hash(url)%xxx 分成 n个文件, B也同样操作. 接着在两文件对应的 a1,b1 里寻找.  索引失效的情况\n  条件中带有or\n  like 以 % 开头\n  多列索引, 没有用第一个\n  某个表中，有两列（id和c_id）都建了单独索引，下面这种查询条件不会走索引\nselect * from test where id=c_id;\n这种情况会被认为还不如走全表扫描\n  条件中包括函数\n  is not, not null\n  ","description":"Java","id":4,"section":"posts","tags":[""],"title":"[面试]-校招Java知识","uri":"https://zhr619151879.github.io/posts/series/interview/java/"},{"content":"HTTPS Hyper Text Transfer Protocol over Secure Socket Layer\nHTTP 有以下安全性问题：\n 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。  ![image-20200818102731080](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818102731080.png)\n![image-20200818105332924](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818105332924.png) 加密算法 对称加密算法(AES DES\u0026hellip;)  共用同一密钥  生成一个⻓度和原始信息一样的随机比特序列作为密钥，然后用它对原始信息做异或运算，就生成了密文。反之，再用该密钥对密文做 一次异或运算，就可以恢复原始信息。\n 但是，一切对称加密算法的软肋在于密钥的配送。加密和解密用同一个密钥，发送方必须设法把密钥发送给接收方。如果窃听者有能力窃取密文，肯定也可以窃取密钥\n 密钥交换算法(DH)  运算的不可逆: 知道hash(),a可以求出hash(a), 知道hash(),hash(a)不能求出a  ![image-20200817114219364](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817114219364.png)\n![image-20200817115608342](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817115608342.png)\n该算法可以在第三者窃听的前提下，算出一个别人无法算出的秘密作为对称性加密算法的密钥，开始对称加密的通信。\n对于该算法，Hack 又想到一种破解方法，不是窃听 Alice 和 Bob 的通信数据，而是直接同时冒充 Alice 和 Bob 的身份，也就是我们说的「中间人攻击」:\n可⻅，密钥交换算法也不算完全解决了密钥配送问题，缺陷在于无法核实对方身份\n所以密钥交换算法之前一般要核实对方身份，比如使用数字签名\n非对称加密 ![image-20200817120346338](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817120346338.png)\n非对称加密算法也无法确定通信 双方的身份，依然会遭到中间人攻击。比如 Hack 拦截 Bob 发出的公钥，然后冒充 Bob 的身份给 Alice 发送自己的公钥，那么不知情的 Alice 就会把私密数据用 Hack 的公钥加密，Hack 可以通过私钥解密窃取。\n那么，Diffie-Hellman 算法和 RSA 非对称加密算法都可以一定程度上解决密 钥配送的问题，也具有相同的缺陷，二者的应用场景有什么区别呢?\n简单来说，根据两种算法的基本原理就可以看出来: 如果双方有一个对称加密方案，希望加密通信，而且不能让别人得到钥匙，\n那么可以使用 Diffie-Hellman 算法交换密钥。 如果你希望任何人都可以对信息加密，而只有你能够解密，那么就使用\nRSA 非对称加密算法，公布公钥。\n数据签名 刚才说非对称加密，把公钥公开用于他人对数据加密然后发给你，只有用你 手上对应的私钥才能将密文解密。其实，私钥也可用用来加密数据的，对于 RSA 算法，私钥加密的数据只有公钥才能解开。\n数字签名也是利用了非对称性密钥的特性，但是和公钥加密完全颠倒过来: 仍然公布公钥，但是用你的私钥加密数据，然后把加密的数据公布出去，这 就是数字签名。\n认证 通过使用 证书 来对通信方进行认证。\n数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。\n服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。\n进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。\n![image-20200818104627496](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818104627496.png)\n![image-20200818104402569](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818104402569.png)\nHTTP 请求报文 ​\t![image-20200818095422794](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818095422794.png)\n响应报文 ![image-20200818095450753](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818095450753.png)\nHTTP方法  GET 获取资源 HEAD 和GEt类似,确认URL的有效性及资源更新的日期时间 (不返回报文实体主体部分) POST 传输数据 PUT 上传文件 PATCH 修改资源(PUT是完全替代),允许部分修改 DELETE OPTIONS 查询指定URL能支持的方法 (返回 Allow: GET,POST..)  ![image-20200818102521316](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818102521316.png)\n状态码  1xx 信息   100 Continue: 目前为止都正常,client可以继续发送\n  2xx 成功   200 OK\n204 No Content 请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。\n206 Partial Content 表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容\n  3xx 重定向   301 Moved Permanently: 永久性重定向\n302 Found: 临时性重定向\n![image-20200818101356459](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818101356459.png)\n303 See Other: 和302相同, 但明确要求客户端用GET方法\n304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码\n307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。\n  4xx 客户端错误    400 Bad Request ：请求报文中存在语法错误。 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。 403 Forbidden ：请求被拒绝。 404 Not Found    5xx 服务器错误    500 Internal Server Error ：服务器正在执行请求时发生错误。 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。   HTTP版本 HTTP 0.9 是一个最古老的版本\n 只支持GET请求方式：由于不支持其他请求方式，因此客户端是没办法向服务端传输太多的信息 没有请求头概念：所以不能在请求中指定版本号，服务端也只具有返回 HTML字符串的能力 服务端相响应之后，立即关闭TCP连接  HTTP1.0\n 请求方式新增了POST，DELETE，PUT，HEADER等方式 增添了请求头和响应头的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码) 扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输  在这个版本主要的就是对请求和响应的元信息进行了扩展，客户端和服务端有更多的获取当前请求的所有信息，进而更好更快的处理请求相关内容。\nHTTP1.1\n 短连接长连接  当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。\n长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。\n 从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close； 在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。 缓存处理：新增字段cache-control  HTTP2.0\n多路复用:\n![image-20200824164454675](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824164454675.png)\n![image-20200818112058576](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818112058576.png)\n![image-20200818112339026](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818112339026.png)\nHTTP3.0\n![image-20200818113006416](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818113006416.png)\nCookies和Session ![image-20200817111637247](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817111637247.png)\n Cookies的建立 (存储在HTTP Header中)  ![image-20200817111727943](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817111727943.png)\n![image-20200818101905446](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818101905446.png)\n作用域\n![image-20200818102137858](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818102137858.png)\n 浏览器禁用 Cookie  此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。\n Session 实现  一般需要三个组件 配合完成，它们分别是 Manager 、 Provider 和 Session 三个类(接 口)。\n![image-20200817112713931](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817112713931.png)\n参数 GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。\n因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参数支持标准字符集。\nGET /test/demo_form.asp?name1=value1\u0026amp;name2=value2 HTTP/1.1 POST /test/demo_form.asp HTTP/1.1 Host: w3schools.com name1=value1\u0026amp;name2=value2 代理 代理服务器接受客户端的请求，并且转发给其它服务器。\n使用代理的主要目的是：\n 缓存 负载均衡 网络访问控制 访问日志记录  ![image-20200818102629316](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818102629316.png)\n负载均衡算法  轮询  轮询算法把每个请求轮流发送到每个服务器上。\n下图中，一共有 6 个客户端产生了 6 个请求，这 6 个请求按 (1, 2, 3, 4, 5, 6) 的顺序发送。(1, 3, 5) 的请求会被发送到服务器 1，(2, 4, 6) 的请求会被发送到服务器 2。\n 加权轮询  加权轮询是在轮询的基础上，根据服务器的性能差异，为服务器赋予一定的权值，性能高的服务器分配更高的权值。\n 最小连接  由于每个请求的连接时间不一样，使用轮询或者加权轮询算法的话，可能会让一台服务器当前连接数过大，而另一台服务器的连接过小，造成负载不均衡。\n 源地址哈希法 随机法 一致性哈希(缓存)  网络  互联网: 网络把主机连接起来，而互连网（internet）是把多种不同的网络连接起来，因此互连网是网络的网络。而互联网（Internet）是全球范围的互连网。  ![image-20200817141322093](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817141322093.png)\n![image-20200817142052676](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817142052676.png)\n时延  总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延  ![image-20200817142825349](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817142825349.png)\n  排队时延:\n 分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。    处理时延\n 主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。    传输时延\n  主机或路由器传输数据帧所需要的时间。\n\n其中 l 表示数据帧的长度，v 表示传输速率\n    (与传播时延的区别): 第一人进入公交-\u0026gt;全部人进入公交.出发!\n 传播时延  电磁波在信道中传播所需要花费的时间    计网体系结构 ![image-20200817143413736](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817143413736.png)\n五层协议   应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。\n  传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。\n运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。\n  网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。\n  数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。\n  物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。\n  OSI 7层模型 其中表示层和会话层用途如下：\n 表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。 会话层 ：建立及管理会话。  五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。\n应用层 DNS域名系统   DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。\n域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。\n  ![image-20200817145103284](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817145103284.png)\n常用端口 ![image-20200817145536378](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817145536378.png)\n传输层 UDP TCP 特点  用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。  UDP\n![image-20200817150852368](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817150852368.png)\n 源端口：这个字段占据 UDP 报文头的前 16 位，通常包含发送数据报的应用程序所使用的 UDP 端口。接收端的应用程序利用这个字段的值作为发送响应的目的地址。这个字段是可选的，所以发送端的应用程序不一定会把自己的端口号写入该字段中。如果不写入端口号，则把这个字段设置为 0。这样，接收端的应用程序就不能发送响应了。 目的端口：接收端计算机上 UDP 软件使用的端口，占据 16 位。 长度：该字段占据 16 位，表示 UDP 数据报长度，包含 UDP 报文头和 UDP 数据长度。因为 UDP 报文头长度是 8 个字节，所以这个值最小为 8。 校验值：该字段占据 16 位，可以检验数据在传输过程中是否被损坏。  TCP\n![image-20200817172706300](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817172706300.png)\n  序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。\n  确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。\n  首部长度 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度(4byte)。\n  确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。\n  同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。\nSYN=1时不能携带数据,但要消耗一个序号.\n  终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。\n  PSH: 表示有 DATA数据传输\n  RST: 表示连接重置\n  窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的\n  三次握手 四次挥手 ![image-20200817174036661](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817174036661.png)\nA下一次发请求时Seq依旧是x+1!!!!因为ack不占序号位(SYN,FIN占)\n 四次挥手  MSL: Maximum Segment Lifetime, 报文最大生存时间.\n![image-20200817175141860](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817175141860.png)\n【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？\n答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，\u0026ldquo;你发的FIN报文我收到了\u0026rdquo;。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。\n【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？\n答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。\n即在2MSL时间内如果对方都没有超时重发报文则证明ACK发送成功.\n【问题3】为什么是三次握手而不是二次或四次?\n![image-20200817180555817](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817180555817.png)\n TCP 需要 seq 序列号来做可靠重传或接收，而避免连接复用时无法分辨出 seq 是延迟或者是旧链接的 seq，因此需要三次握手来约定确定双方的 ISN（初始 seq 序列号）。  ![image-20200817180726116](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817180726116.png)\n​\t+即B不知道A接受包的能力.\n​\t+为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误\n![image-20200817181702213](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817181702213.png)\n![image-20200817182001921](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817182001921.png)\n![image-20200817182314938](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817182314938.png)\n![image-20200817182540237](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817182540237.png)\n 状态  ![image-20200817180406086](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817180406086.png)\n![image-20200817180415850](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817180415850.png)\n为什么TCP可靠  面向连接(三次握手) 超时重传  TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。\n一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：\n![image-20200817151159507](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817151159507.png)\n其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。\n超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：\n![image-20200817151214999](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817151214999.png)\n其中 RTTd 为偏差的加权平均值。\n 流量控制  滑动窗口\n![image-20200817155907524](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817155907524.png)\n流量控制是为了控制发送方发送速率，保证接收方来得及接收。\n接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。\n 拥塞控制  TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。\n![image-20200817153955134](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817153955134.png)\n慢开始与拥塞避免\n![image-20200817154949441](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817154949441.png)\n快重传与快恢复\n![image-20200817155116054](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817155116054.png)\nTCP粘包问题  UDP不会出现,因为UDP是以数据包形式, 而TCP以数据流形式. 例如一个2k,4k,4k的包,UDP要3次,而TCP可以一次(只要客户端能接受12k) UDP有边界, 而TCP没有, 所以有可能两个数据包首尾相连(两个并行的互不相干的数据包)  产生原因\n  服务端为了优化:\nnagle算法: 1: 等到上一次接受才发下一次\n​\t2: 将几个小的数据包合并到一个大的发送.\n  客户端:\n数据在缓冲区等待应用层读取, 如果 缓冲数据\u0026gt; 应用读取速度,则会发生.\n  问题: 如果TCP A端像B端 发送了100字节, 再发100字节, B端会分别收到两次100字节吗?\n 不一定会~  ![image-20200825100604900](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825100604900.png)\n![image-20200825100613591](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825100613591.png)\n应用程序写入的数据大于套接字缓冲区大小，这将会发生拆包。\n应用程序写入数据小于套接字缓冲区大小，网卡将应用多次写入的数据发送到网络上，这将会发生粘包。\n进行mss（最大报文长度）大小的TCP分段，当TCP报文长度-TCP头部长度\u0026gt;mss的时候将发生拆包。\n接收方法不及时读取套接字缓冲区数据，这将发生粘包\n![image-20200825100752331](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200825100752331.png)\n简而言之，就是 TCP 不管你发出的数据包的业务含义，它只考虑一次性发多少字节比较合适，这就导致了有可能两个不相关的数据包被合并发送\nListen() 后创建连接还是accept() ![image-20200902220653185](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200902220653185.png)\n当客户端调用connect函数时，将引发三次握手过程，如上图所示，客户端首先发送SYN请求分组，此时服务端会将请求放入SYN队列，同时向客户端发送ACK确认报文，然后客户端向服务端再次发送ACK报文。服务端收到ACK确认报文后，将SYN里的连接请求移入ACCEPT队列。此时三次握手结束，即TCP连接成功建立。然后内核通知用户空间的阻塞的服务进程，服务进程调用accept仅仅是从ACCEPT队列里取出一个连接而已。也就是说客户端调用connect连接服务器，与服务器调用accept“接受”连接是两个独立的过程。\n网络层 与 IP 协议配套使用的还有三个协议：\n 地址解析协议 ARP（Address Resolution Protocol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol）  IP数据报格式 ![image-20200817161106636](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817161106636.png)\n  版本 : 有 4（IPv4）和 6（IPv6）两个值；\n  首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为固定部分长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。\n  区分服务 : 用来获得更好的服务，一般情况下不使用。\n  总长度 : 包括首部长度和数据部分长度。\n  生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。\n  协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。\n  首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。\n  标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。由3比特组成。\n第一位：0\u0026ndash;未使用。现在必须为0\n第二位：1\u0026ndash;指示是否进行分片 ：0\u0026ndash;可以分片，1\u0026ndash;不能分片\n第三位：2\u0026ndash;包被分片的情况下，表示是否为最后一个包 0\u0026ndash;最后一个分片的包 1\u0026ndash;分片中段的包\n  片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。\n  ![image-20200817161644698](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817161644698.png)\n MTU(最大传输单元 [首部(20字节)+数据])  ![image-20200817162106660](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817162106660.png)\n子网编码 CIDR记法: 采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。\n地址解析协议ARP  ARP实现由IP地址得到MAC地址  ![image-20200817162841841](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817162841841.png)\n![image-20200817163052253](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817163052253.png)\nICMP ICMP协议的功能主要有：\n 确认IP包是否成功到达目标地址 通知在发送过程中IP包被丢弃的原因  ![image-20200817164728347](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817164728347.png)\n![image-20200817164759870](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817164759870.png)\n问题: telnet是23端口，ssh是22端口，那么ping是什么端口?\n答：ping命令是基于ICMP，是在网络层。\n而端口号，是传输层的内容。所以在ICMP中根本就不关注端口号这样的信息。\n路由 ![image-20200817163213976](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817163213976.png)\n链路层   Mac地址:\nMAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。\n一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。\n  ","description":"Net","id":5,"section":"posts","tags":[""],"title":"[面试]-校招计算机网络知识","uri":"https://zhr619151879.github.io/posts/series/interview/%E7%BD%91%E7%BB%9C/"},{"content":"Mysql SQL执行过程 ![image-20200831221827719](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200831221827719.png)\n事务 事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚。\nACID ![image-20200818162605438](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818162605438.png)\n并发一致性问题  丢失修改  ![image-20200818162810687](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818162810687.png)\n 读脏数据(读未提交)  读脏数据指在不同的事务下，当前事务可以读到另外事务未提交的数据。例如：T1 修改一个数据但未提交，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。\n 不可重复度  不可重复读指在一个事务内多次读取同一数据集合。在这一事务还未结束前，另一事务也访问了该同一数据集合并做了修改，由于第二个事务的修改，第一次事务的两次读取的数据可能不一致。例如：T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同\n 幻读 (侧重在读-写, 不可重复度侧重读-读)  并不是说两次读取获取的结果集不同，幻读侧重的方面是某一次的 select 操作得到的结果所表征的数据状态无法支撑后续的业务操作。更为具体一些：select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入，此时就发生了幻读。\n四大隔离级别  读未提交 (Read Uncommitted)  事务中的修改，即使没有提交，对其它事务也是可见的。\n 提交读(Read Commited)  一个事务只能读取已经提交的事务所做的修改\n 可重复读 (Repeatable Read)[默认隔离级别]   Innodb使用 MVCC解决版本读 , 使用Gap间隙锁解决当前读(for update)\n为什么for update不能解决?因为锁行可以保证该行没有修改,但是不能保证没有新增删除~. 所以用gap锁(在记录之间的间隙加锁)\n ![image-20200820164029348](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820164029348.png)\n锁住的范围是整张表, 不可插入与删除\n版本读\n保证在同一个事务中多次读取同一数据的结果是一样的。\n使用MVCC实现(多版本并发控制 Multiversion concurrency control)\n![image-20200818165602216](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818165602216.png)\n 可串行化(加行锁)  强制事务串行执行，这样多个事务互不干扰，不会出现并发一致性问题。\n该隔离级别需要加锁实现，因为要使用加锁机制保证同一时间只有一个事务执行，也就是保证事务串行执行。\n![image-20200818163946914](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818163946914.png)\n锁类型 封锁粒度 MySQL 中提供了两种封锁粒度：行级锁以及表级锁。\n应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。\n但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。\n在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。\n读写锁  互斥锁（Exclusive），简写为 X 锁，又称写锁。 共享锁（Shared），简写为 S 锁，又称读锁。  规定\n 一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。 一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。  ![image-20200818170037764](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818170037764.png)\n意向锁 举个例子，如果表中记录1亿，事务A把其中有几条记录上了行锁了，这时事务B需要给这个表加表级锁，如果没有意向锁的话，那就要去表中查找这一亿条记录是否上锁了。如果存在意向锁，那么假如事务Ａ在更新一条记录之前，先加意向锁，再加Ｘ锁，事务B先检查该表上是否存在意向锁，存在的意向锁是否与自己准备加的锁冲突，如果有冲突，则等待直到事务Ａ释放，而无须逐条记录去检测。事务Ｂ更新表时，其实无须知道到底哪一行被锁了，它只要知道反正有一行被锁了就行了。\n说白了意向锁的主要作用是处理行锁和表锁之间的矛盾，能够显示“某个事务正在某一行上持有了锁，或者准备去持有锁”\n![image-20200818170925490](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818170925490.png)\n![image-20200818170937145](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818170937145.png)\n 任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁； 这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）  （如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务； 反之， 如果两者不兼容，该事务就要等待锁释放。）\n乐观锁 悲观锁  乐观锁(Optimistic Lock)：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 乐观锁不能解决脏读的问题。  乐观锁, 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。\n 类似于 SVN、GIt 这些版本管理系统，当修改了某个文件需要提交的时候，它会检查文件的当前版本是否与服务器上的一致，如果一致那就可以直接提交，如果不一致，那就必须先更新服务器上的最新代码然后再提交（也就是先将这个文件的版本更新成和服务器一样的版本）\n ![image-20200818174251947](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818174251947.png)\n 悲观锁(Pessimistic Lock)：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。  悲观锁，顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。\n![image-20200818174336392](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818174336392.png)\n死锁 死锁的关键在于**：两个(**或以上)**的Session**加锁的顺序不一致。\n那么对应的解决死锁问题的关键就是：让不同的session加锁有次序\n死锁一般是事务相互等待对方资源，最后形成环路造成的。下面简单讲下造成相互等待最后形成环路的例子\n![image-20200820155230765](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820155230765.png)\n 死锁检测  死锁检测的原理是构建一个以事务为顶点、锁为边的有向图，判断有向图是否存在环，存在即有死锁。\n 回滚  检测到死锁之后，选择插入更新或者删除的行数最少的事务回滚，基于 INFORMATION_SCHEMA.INNODB_TRX 表中的 trx_weight 字段来判断。\n分布式事务 2PC 两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。\n 准备阶段  协调者询问参与者事务是否执行成功，参与者发回事务执行结果。询问可以看成一种投票，需要参与者都同意才能执行。\n![image-20200820172654325](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820172654325.png)\n 提交阶段  ![image-20200820172741204](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820172741204.png)\n缺点\n![image-20200820172825232](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820172825232.png)\n本地消息表 ![image-20200820173305312](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820173305312.png)\nCAP 与 BASE CAP ![image-20200820173417098](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820173417098.png)\nBASE BASE 是基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个短语的缩写。\nBASE 理论是对 CAP 中一致性和可用性权衡的结果，它的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n![image-20200820173537533](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820173537533.png)\n索引 索引类别 Myisam和 innodb都是B+数结构.\n索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。\nB tree  m阶B树(m叉树) ![image-20200516222741370](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200516222741370.png)    每个节点最多含有m个孩子 除根和叶子、其他节点至少有**[ceil(m/2)]**个孩子 根至少有2个孩子 所有叶子在同一层、叶子不包含任何关键字信息 对于每个非叶子：   1）Ki 为关键字、升序排序\n2）Pi为指向孩子的指针，其所指孩子关键字 小于Ki，大于K(i-1）\n3）关键字个数n： [ceil(m/2)-1]\u0026lt;=n\u0026lt;=m-1\n   B 树插入： 小了合并、大了分裂 （中间元素上移）  ![image-20200516220029953](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200516220029953.png)\nB+ tree ![image-20200516221509731](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200516221509731.png)\n![image-20200516223121416](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200516223121416.png)\n对比 ![image-20200516223108377](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200516223108377.png)\n (1）B+树只有叶子节点会带有指向记录的指针(带数据)，而B树则所有节点都带有。\n(2）B+树中所有叶子节点都是通过指针连接在一起的，而B树不会。\nB+树的优点:\n(1）非叶子节点不带数据，这样一个块可以容纳更多的索引项，一是可以降低树的高度，二是一个内部节点可以定位更多的叶子节点。\n(2）叶子节点之间通过指针连接，范围扫描将十分简单。而对于B树来说，则需要在叶子节点和内部节点间不停的往返移动。\nB树的优点：\n对于在内部节点的数据，可直接得到，不必根据叶子节点来定位\n  B树查找次数不稳定(可能叶子可能非叶子), B+树查找稳定 但是两者都比红黑树IO次数好,因为层数低  与红黑树的比较 ![image-20200819204545590](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200819204545590.png)\n两种引擎: 存储引擎: * 表的类型在计算机上的存储方式  MyISAM MyISAM的优势在于占用空间小，处理速度快。缺点是不支持事务的完整性和并发性。\n![image-20200803112457436](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200803112457436.png)\n myi 记录索引, 叶子节点记录该键值在.myd的偏移量 frm: 表的结构 得到偏移量后是随机访问,速度快.  Innodb(支持事务处理,回滚)  默认引擎 InnoDB的优势在于提供了良好的事务处理、崩溃修复能力和并发控制。缺点是读写效率较差，占用的数据空间相对较大。  ![image-20200803112829476](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200803112829476.png)\n Innodb中，索引分叶子节点和非叶子节点，非叶子节点就像新华字典的目录，单独存放在索引段中，叶子节点则是顺序排列的  比较 ![image-20200812220342047](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200812220342047.png)\n 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。 外键：InnoDB 支持外键。 备份：InnoDB 支持在线热备份。 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。 其它特性：MyISAM 支持压缩表和空间数据索引。  主键索引 非主键索引 ![image-20200812224030437](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200812224030437.png)\n聚集索引, 非聚集索引 ![image-20200819214011104](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200819214011104.png)\n![image-20200819214137184](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200819214137184.png)\n![image-20200812224826481](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200812224826481.png)\n![image-20200812224921090](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200812224921090.png)\n聚集索引适合应用于含有大量非重复值的列；使用BETWEEN,\u0026gt;,\u0026gt;=,\u0026lt;或\u0026lt;=返回一个范围值的列；被连续访问的列；返回大型结果集的查询；经常被使用连接或GROUP BY子句的查询访问的列。\n非聚集索引适用于经常被分组排序的列；大数目的不同值；频繁更新的列；外键列；主键列；频繁修改索引列。\n为什么要使用自增主键 ![image-20200819223723163](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200819223723163.png)\n查询优化 Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。\n  select_type : 查询类型，有简单查询、联合查询、子查询等 key : 使用的索引 rows : 扫描的行数   优化数据访问 减少请求的数据量\n 只返回必要的列: 最好不要用select *  ![image-20200819205429506](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200819205429506.png)\n 只返回必要的行: LIMIT来限制 缓存重复查询的数据: 使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。  减少服务器端扫描的行数\n 最有效的方式是使用索引来覆盖查询。  重构查询方式  切分大查询  一次性查询分为多次使用.\n 分解大连接查询  可以将原来的连接分解成多个单表查询，然后在用户程序中进行连接。\n 尽量不要子查询, 不要having.  具体方法  IN OR字句会使索引失效.  读写分离   主从复制\n![image-20200819224310196](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200819224310196.png)\n  主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。\n读写分离能提高性能的原因在于：\n 主从服务器负责各自的读和写，极大程度缓解了锁的争用； 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销； 增加冗余，提高可用性。  读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。\n![image-20200819211511372](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200819211511372.png)\n读写分离其实只是分担了访问的压力，但是存储的压力没有解决。\nBinLog的两种方式\n statement: 记录所有sql修改语句, 重新执行 row : 记录变动的行的数据.  切分 单库多表: 解决数据大时每次写都有表级锁的问题\n水平切分 主要解决问题：\n 单表过大造成的性能问题； 单表过大造成的单服务器空间问题。  ![image-20200819210526051](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200819210526051.png)\n可以用Merge引擎分表.\n![image-20200820144744753](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820144744753.png)\n 问题: Order By的话就都得多次~  垂直切分 主要解决问题：\n 表与表之间资源争用问题； 锁争用机率小； 实现核心与非核心的分级存储，如UDB登陆库拆分成一级二级三级库； 数据库同步压力问题。 可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数  ![image-20200819210732296](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200819210732296.png)\n 那垂直分表影响就是之前只要一个查询的，现在需要两次查询才能拿到分表之前的完整用户表信息。  Sharding 策略  哈希取模：hash(key) % N； 范围：可以是 ID 范围也可以是时间范围； 映射表：使用单独的一个数据库来存储映射关系。  Redis 概述 Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。\n键的类型只能为字符串，值支持五种数据类型：字符串、列表、集合、散列表、有序集合。\nRedis 支持很多特性，例如将内存中的数据持久化到硬盘中，使用复制来扩展读性能，使用分片来扩展写性能。\n![image-20200819225403071](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200819225403071.png)\n数据结构 DICT  拉链法解决冲突  ![image-20200820101620129](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820101620129.png)\n![image-20200820103429535](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820103429535.png)\n跳表 https://www.jianshu.com/p/61f8cad04177\n应用在有序集合 (ZSET)\n跳跃表支持平均 O(\\log N) 最坏 O(N) 复杂度的节点查找\n ​\t1、由很多层结构组成；\n　2、每一层都是一个有序的链表，排列顺序为由高层到底层，都至少包含两个链表节点，分别是前面的head节点和后面的nil节点；\n　3、最底层的链表包含了所有的元素；\n　4、如果一个元素出现在某一层的链表中，那么在该层之下的链表也全都会出现（上一层的元素是当前层的元素的子集）；\n　5、链表中的每个节点都包含两个指针，一个指向同一层的下一个链表节点，另一个指向下一层的同一个链表节点；\n ![image-20200819233001612](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200819233001612.png)\n 插入速度非常快速，因为不需要进行旋转等操作来维护平衡性； 更容易实现； 支持无锁操作。   ​\t①、搜索：从最高层的链表节点开始，如果比当前节点要大和比当前层的下一个节点要小，那么则往下找，也就是和当前层的下一层的节点的下一个节点进行比较，以此类推，一直找到最底层的最后一个节点，如果找到则返回，反之则返回空。\n　②、插入：首先确定插入的层数，有一种方法是假设抛一枚硬币，如果是正面就累加，直到遇见反面为止，最后记录正面的次数作为插入的层数。当确定插入的层数k后，则需要将新元素插入到从底层到k层。\ndo( 插入层数+=1)while random() \u0026gt; 0.5\n　③、删除：在各个层中找到包含指定值的节点，然后将节点从链表中删除即可，如果删除以后只剩下头尾两个节点，则删除这一层。\n ![image-20200820114054430](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820114054430.png)\n![image-20200820112118645](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200820112118645.png)\n如上,当节点数\u0026gt;128或节点值大于某一个长度, 则转换成跳表(原来是字节数组)\n持久化 https://baijiahao.baidu.com/s?id=1654694618189745916\u0026amp;wfr=spider\u0026amp;for=pc\nRDB  将某个时间点的所有数据都存放到硬盘上。\n可以将快照复制到其他服务器从而创建具有相同数据的服务器副本。\n如果系统发生故障，将会丢失最后一次创建快照之后的数据。\n如果数据量大，保存快照的时间会很长\n AOF ![image-20200812231937382](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200812231937382.png)\n主从复制 ![image-20200812232013362](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200812232013362.png)\nSentinel Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。\n缓存问题 缓存穿透 指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。\n解决方案：\n 对这些不存在的数据缓存一个空数据； 对这类请求进行过滤。  缓存雪崩 指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。\n在有缓存的系统中，系统非常依赖于缓存，缓存分担了很大一部分的数据请求。当发生缓存雪崩时，数据库无法处理这么大的请求，导致数据库崩溃。\n解决方案：\n 为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现； 为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。 也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。  分布式锁  setnx  ![image-20200831215724759](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200831215724759.png)\n Redisson 组件. 使用lua脚本实现原子性  Redis缓存与数据库同步方案  延时双删  1）先删除缓存\n2）再写数据库\n3）休眠500毫秒\n4）再次删除缓存\n  binlog异步刷新\n  MQ串行化\n  问题就来自于“读数据库” + “写缓存” 之间的交错并发，那怎么来避免呢？\n有一个方法就是：串行化，我们利用MQ将所有“读数据库” + “写缓存”的步骤串行化\n![image-20200831222849522](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200831222849522.png)\nRedis内存淘汰策略 过期策略  定期删除  ![image-20200913182936522](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200913182936522.png)\n 惰性删除  ![image-20200913183007954](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200913183007954.png)\n why淘汰策略:  因为不管是定期采样删除还是惰性删除都不是一种完全精准的删除，就还是会存在key没有被删除掉的场景，所以就需要内存淘汰策略进行补充。\n内存淘汰策略 Redis的内存淘汰策略是指在Redis的用于缓存的内存不足时，怎么处理需要新写入且需要申请额外空间的数据。\nRedis的LRU实现\nRedis维护了一个24位时钟，可以简单理解为当前系统的时间戳，每隔一定时间会更新这个时钟。每个key对象内部同样维护了一个24位的时钟，当新增key对象的时候会把系统的时钟赋值到这个内部对象时钟。比如我现在要进行LRU，那么首先拿到当前的全局时钟，然后再找到内部时钟与全局时钟距离时间最久的（差最大）进行淘汰，这里值得注意的是全局时钟只有24位，按秒为单位来表示才能存储194天，所以可能会出现key的时钟大于全局时钟的情况，如果这种情况出现那么就两个相加而不是相减来求最久的key。\n","description":"DataBase","id":6,"section":"posts","tags":[""],"title":"[面试]-校招数据库知识","uri":"https://zhr619151879.github.io/posts/series/interview/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"content":"Linux ![image-20200902214702059](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200902214702059.png)\n用户态, 内核态  https://zhuanlan.zhihu.com/p/69554144\n   内核，它是一种特殊的软件程序,控制计算机的硬件资源，例如协调CPU资源，分配内存资源，并且提供稳定的环境供应用程序运行。\n用户态就是提供应用程序运行的空间，为了使应用程序访问到内核管理的资源例如CPU，内存，I/O。内核必须提供一组通用的访问接口，这些接口就叫系统调用。\n   给不同的操作给与不同的“权限”。Linux操作系统就将权限等级分为了2个等级，分别就是内核态和用户态。\n ![image-20200812211412621](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200812211412621.png)\n![image-20200815224732295](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200815224732295.png)\nFork    一个现有进程可以调用fork函数创建一个新进程。由fork创建的新进程被称为子进程（child process）。fork函数被调用一次但返回两次。两次返回的唯一区别是子进程中返回0值而父进程中返回子进程ID。\n  子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的“副本”，这意味着父子进程间不共享这些存储空间。\n  调用fork之后，数据、堆、栈有两份，代码仍然为一份但是这个代码段成为两个进程的共享代码段都从fork函数中返回，箭头表示各自的执行处。当父子进程有一个想要修改数据或者堆栈时，两个进程真正分裂\n   vFork()\n 1.fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段 2.fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。 3.vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个函数之前子进程依赖于父进程的进一步动作，则会导致死锁。 4.当需要改变共享数据段中变量的值，则拷贝父进程。  Chmod权限   chmod 741 r读 w写 x执行 r=4, w=2, x=1  第一个数字表示文件所有者的权限\n第二个数字表示与文件所有者同属一个用户组的其他用户的权限\n第三个数字表示其它用户组的权限。\n chmod 4755与chmod 755 的区别在于开头多了一位，这个4表示其他用户执行文件时，具有与所有者相当的权限   缓冲 与 缓存  缓冲区  缓冲区(buffer)，它是内存空间的一部分。也就是说，在内存空间中预留了一定的存储空间，这些存储空间用来缓冲输入或输出的数据，这部分预留的空间就叫做缓冲区，显然缓冲区是具有一定大小的。\n缓冲区根据其对应的是输入设备还是输出设备，分为输入缓冲区和输出缓冲区。\n![image-20200831104401236](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200831104401236.png)\n下列情况会引发缓冲区的刷新:\n 缓冲区满时； 关闭文件。  IO多路复用 单线程或单进程同时监测若干个文件描述符是否可以执行IO操作的能力。\n 阻塞式I/O  ![image-20200824095743639](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824095743639.png)\n  非阻塞式 (轮询)\n  I/O多路复用\n  ![image-20200824095855942](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824095855942.png)\n IO多路复用是一种同步IO模型，实现一个线程可以监视多个文件句柄；一旦某个文件句柄就绪，就能够通知应用程序进行相应的读写操作；没有文件句柄就绪时会阻塞应用程序，交出cpu。多路是指网络连接，复用指的是同一个线程  ![image-20200824171018312](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824171018312.png)\n![image-20200824100231640](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824100231640.png)\nselect 和 poll 速度都比较慢，每次调用都需要将全部描述符从应用进程缓冲区复制到内核缓冲区。\n![image-20200824223427021](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200824223427021.png)\n epoll的工作模式  工作模式\n LT 模式  当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。\nET 模式  和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。\n很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。\n操作系统 内存管理 块与页的关系：操作系统经常与内存和硬盘这两种存储设备进行通信，类似于“块”的概念，都需要一种虚拟的基本单位。所以，与内存操作，是虚拟一个页的概念来作为最小单位。与硬盘打交道，就是以块为最小单位\n虚拟内存  一个进程不用全部进入内存, 与磁盘进行映射.建立虚拟内存. 为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令 虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。  ![image-20200815233314455](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200815233314455.png)\n虚拟地址转换成物理地址 操作系统为每一个进程维护了一个从虚拟地址到物理地址的映射关系的数据结构，叫页表。页表的内容就是该进程的虚拟地址到物理地址的一个映射。页表中的每一项都记录了这个页的基地址。通过页表，由逻辑地址的高位部分先找到逻辑地址对应的页基地址，再由页基地址偏移一定长度就得到最后的物理地址\n![image-20200819105752023](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200819105752023.png)\n 两级页表:\n 两级分页机制将32位的虚拟空间分成三段，低十二位表示页内偏移，高20分成两段分别表示两级页表的偏移。  ![image-20200815234805503](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200815234805503.png)\n   虚拟地址-\u0026gt;物理地址:\n![image-20200815222302207](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200815222302207.png)\n  ![image-20200815233433512](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200815233433512.png)\n![image-20200819105652934](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200819105652934.png)\n页面调度算法 LRU:\n时间片: 环形链表,依次出\nFIFO\n第二次机会(FIFO改进)\n![image-20200815223155203](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200815223155203.png)\n段 页式存储 程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。\n![image-20200815223429817](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200815223429817.png)\n缺页中断  malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常。 缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存中。每当所要访问的页面不在内存时，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存。 缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：  1.保护CPU现场 2.分析中断原因 3.转入缺页中断处理程序进行处理 4.恢复CPU现场，继续执行   但是，如果缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断时。因此，与一般的中断存在区别：  1.在指令执行期间产生和处理缺页中断信号 2.一条指令在执行期间，可能产生多次缺页中断 3.缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。    磁盘  磁盘块：逻辑层面： 磁盘块（虚拟出来的）。 块是操作系统中最小的逻辑存储单位。操作系统与磁盘打交道的最小单位是磁盘块。 操作系统是通过块簇来做为单位读取等操作数据的**。文件系统就是操作系统的一部分，所以文件系统操作文件的最小单位是块。\n目的：1.读取方便：由于扇区的数量比较小，数目众多在寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。2.分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为块是最小的单位\n 磁盘结构   盘面（Platter）：一个磁盘有多个盘面； 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道； 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小； 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）； 制动手臂（Actuator arm）：用于在磁道之间移动磁头； 主轴（Spindle）：使整个盘面转动。   ![image-20200815223555242](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200815223555242.png)\n磁盘调度  最短寻道 电梯算法 先来先服务  进程和线程  线程是独立调度的基本单位。\n一个进程中可以有多个线程，它们共享进程资源。\n 并发 并行   并发: 宏观上一段时间内能同时运行多个程序 并行: 同一时刻能运行多个指令   区别   拥有资源  进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。\n 调度  线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。\n 系统开销  由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。\n类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。\n 通信方面  线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。\n![image-20200814205933707](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200814205933707.png)\n Linux的进程线程无区别  计算机结构:  ![image-20200817111350658](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817111350658.png)\n 内核角度看没有区别  系统调用 fork() 可以新建一个子进程，函数 pthread() 可以新建 一个线程。但无论线程还是进程，都是用 task_struct 结构表示的，唯一的 区别就是共享的数据区域不同。\n换句话说，线程看起来跟进程没有区别，只是线程的某些数据区域和其父进 程是共享的，而子进程是拷⻉副本，而不是共享。就比如说， mm 结构\n和 files 结构在线程中都是共享的\n![image-20200817110159449](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817110159449.png)\n![image-20200817110311791](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200817110311791.png)\n进程/线程通信 进程通信方法:\n pipe()管道:   管道的通信介质是文件，这种文件通常称为管道文件，两个进程利用管道文件进行通信时，一个进程为写进程，另一个进程为读进程。写进程通过写端（发送端）往管道文件中写入信息；读进程通过读端（接收端）从管道文件中读取信息\n通过fork()进行, 在内存缓冲区.\n 只支持单向交替传输 只能在父子或兄弟进程使用    消息队列   ![image-20200814210447128](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200814210447128.png)\n 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难； 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法； 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。    信号:   信号是一种比较复杂的通信方式，信号产生的条件：按键、硬件异常、进程调用kill函数将信号发送给另一个进程、用户调用kill命令将信号发送给其他进程，信号传递的消息比较少，主要用于通知接收进程某个时间已经发生。\n  共享内存  ![image-20200814210701617](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200814210701617.png)\n![image-20200815212714552](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200815212714552.png)\n 本地套接字  进程间通信的一种方式是使用UNIX套接字sockaddr_un，人们在使用这种方式时往往用的不是网络套接字，而是一种称为本地套接字的方式。本地套接字用于本地进程间的通讯更安全和稳定。\n使用套接字函数socket创建，不过传递的参数与网络套接字不同。域参数应该是PF_LOCAL或者PF_UNIX，而不能用PF_INET之类。本地套接字的通讯类型应该是SOCK_STREAM或SOCK_DGRAM，协议为默认协议。\n线程通信\n  临界区：通过多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问； 互斥量Synchronized/Lock：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问 信号量Semphare：为控制具有有限数量的用户资源而设计的，它允许多个线程在同一时刻去访问同一个资源，但一般需要限制同一时刻访问此资源的最大线程数目。 事件(信号)，Wait/Notify：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。   进程同步  同步与互斥   同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。\n互斥：多个进程在同一时刻只有一个进程能进入临界区。\n   临界区: 对临界资源进行访问的代码\n  信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。\n down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0； up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。 如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。    管程:\n   使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。\n管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。\n管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。\n  生产者消费者  ![image-20200814215805809](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200814215805809.png)\n读者写者\n![image-20200814220744221](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200814220744221.png)\n死锁  必要条件   互斥：每个资源要么已经分配给了一个进程，要么就是可用的。\n占有和等待：已经得到了某个资源的进程可以再请求新的资源。\n不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。\n环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。\n  解决方法   鸵鸟\n修复: 回滚,抢占, 杀死进程\u0026hellip;.\n预防:破坏四个条件\n避免: 银行家算法\n  银行家算法:  为了实现银行家算法，必须设置以下四个数据结构:\n（1）可利用资源向量Available:其初始值是系统中所配置的该类全部可用资源的数目。\n（2）最大需求矩阵Max:它定义了系统中n个进程中的每一个进程对m类资源的最大需求。\n（3）分配矩阵Allocation:它定义了系统中每一类资源当前已分配给每一个进程的资源数。\n（4）需求矩阵Need：用一表示每一个进程尚需的各类资源数\n （1）如果Request(i)[j] \u0026lt;= Need[i,j],便转向步骤2,否则出错；\n（2）如果Request(i)[j] \u0026lt;= Available[j],便转向步骤3，否则出错；\n（3）系统试探着把资源分配给进程P,并修改下面数据结构中的数值:\n(非常重要)\nAvailable[j] = Avaliable[j] - Request(i)[j];\nAllocation[i,j] = Allocation[i,j] + Request(i)[j];\nNeed[i,j] = Need[i,j] - Request(i)[j];\n（4）执行安全性算法,检查此次资源分配后系统是否处于安全状态。安全则分配，否则分配作废。\n 安全性算法: 剩下的资源能否满足任一进程的所有要求.\n有了进程，为什么还要有线程？   线程产生的原因：进程可以使多个程序能并发执行，以提高资源的利用率和系统的吞吐量；但是其具有一些缺点：进程在同一时间只能干一件事、进程在执行的过程中如果阻塞，整个进程就会挂起，即使进程中有些工作不依赖于等待的资源，仍然不会执行。\n  因此，操作系统引入了比进程粒度更小的线程，作为并发执行的基本单位，从而减少程序在并发执行时所付出的时空开销，提高并发性。\n和进程相比，线程的优势如下\n 从资源上来讲，线程是一种非常\u0026quot;节俭\u0026quot;的多任务操作方式。在Linux系统下，启动一个新的进程必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种\u0026quot;昂贵\u0026quot;的多任务工作方式。 从切换效率上来讲，运行于一个进程中的多个线程，它们之间使用相同的地址空间，而且线程间彼此切换所需时间也远远小于进程间切换所需要的时间。据统计，一个进程的开销大约是一个线程开销的30倍左右。  ![image-20200818094442079](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200818094442079.png)\n 从通信机制上来讲，线程间方便的通信机制。对不同进程来说，它们具有独立的数据空间，要进行数据的传递只能通过进程间通信的方式进行，这种方式不仅费时，而且很不方便。线程则不然，由于同一进城下的线程之间贡献数据空间，所以一个线程的数据可以直接为其他线程所用，这不仅快捷，而且方便。 使多CPU系统更加有效。操作系统会保证当线程数不大于CPU数目时，不同的线程运行于不同的CPU上。 改善程序结构。一个既长又复杂的进程可以考虑分为多个线程，成为几个独立或半独立的运行部分，这样的程序才会利于理解和修改。    多线程和多进程的不同?  进程是资源分配的最小单位，而线程时CPU调度的最小单位。多线程之间共享同一个进程的地址空间，线程间通信简单，同步复杂，线程创建、销毁和切换简单，速度快，占用内存少，适用于多核分布式系统，但是线程间会相互影响，一个线程意外终止会导致同一个进程的其他线程也终止，程序可靠性弱。而多进程间拥有各自独立的运行地址空间，进程间不会相互影响，程序可靠性强，但是进程创建、销毁和切换复杂，速度慢，占用内存多，进程间通信复杂，但是同步简单，适用于多核、多机分布。   线程共享的资源  ![image-20200831165158571](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200831165158571.png)\n正常进程、孤儿进程、僵尸进程 wait()\npid_t wait(int *status) 父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。\n如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。\n参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。\nwaitpid()\npid_t waitpid(pid_t pid, int *status, int options) 作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。\npid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid=-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。\noptions 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。\n 1.正常进程：正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到：在每个进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。 但是仍然为其保留一定的信息，直到父进程通过wait / waitpid来取时才释放。保存信息包括：\n 进程号the process ID 退出状态the termination status of the process 运行时间the amount of CPU time taken by the process等  2.孤儿进程：\n一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。\n孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。\n由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。\n3.僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。僵尸进程是一个进程必然会经过的过程：这是每个子进程在结束时都要经过的阶段。如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是“Z”。如果父进程能及时 处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。\n 危害： 如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程\n解决方法：\n 外部消灭：通过kill发送SIGTERM或者SIGKILL信号消灭产生僵尸进程的进程，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源。 内部解决：子进程退出时向父进程发送SIGCHILD信号，父进程处理SIGCHILD信号。在信号处理函数中调用wait进行处理僵尸进程；fork两次，原理是将子进程成为孤儿进程，从而其的父进程变为init进程，通过init进程可以处理僵尸进程。  缓存结构 CPU 三级缓存 ![image-20200922100631600](/Users/zhuhaoran/Library/Application Support/typora-user-images/image-20200922100631600.png)\nCPU试图通过某一存储单元地址访问数据时，它会自上而下依次从L1、L2、L3、主存中查找，若找到则直接返回对应Cache中的数据而不再向下查找，如果L1、L2、L3都cache miss了，那么CPU将不得不通过总线访问主存或者硬盘上的数据。\n缓存Cache结构 整个Cache被分为S个组，每个组又有E行个最小的存储单元——Cache Line所组成，而一个Cache Line中有B（B=64）个字节用来存储数据，即每个Cache Line能存储64个字节的数据，每个Cache Line又额外包含1个有效位（valid bit）、t个标记位（tag bit），其中valid bit用来表示该缓存行是否有效；tag bit用来协助寻址，唯一标识存储在Cache Line中的块；而Cache Line里的64个字节其实是对应内存地址中的数据拷贝。根据Cache的结构，我们可以推算出每一级Cache的大小为B×E×S。\n","description":"Operation systeam","id":7,"section":"posts","tags":[""],"title":"[面试]-校招操作系统知识","uri":"https://zhr619151879.github.io/posts/series/interview/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"content":"afdsaf\n","description":"GRPC","id":10,"section":"posts","tags":[""],"title":"[GRPC详解]-1","uri":"https://zhr619151879.github.io/posts/series/grpc/grpc/"},{"content":"A Poor Gopher\n","description":"Hugo, the world’s fastest framework for building websites","id":12,"section":"","tags":null,"title":"About","uri":"https://zhr619151879.github.io/about/"},{"content":"HelloWorld!\n","description":"This is my awesome post!","id":13,"section":"posts","tags":[""],"title":"My First Post","uri":"https://zhr619151879.github.io/posts/leetcode/myfirstpost/"},{"content":"Sample images from Pixabay\n","description":"cartoon gallery","id":14,"section":"gallery","tags":null,"title":"Cartoon","uri":"https://zhr619151879.github.io/gallery/cartoon/"},{"content":"Sample images from Pixabay\n","description":"photo gallery","id":15,"section":"gallery","tags":null,"title":"Photo","uri":"https://zhr619151879.github.io/gallery/photo/"}]